<!DOCTYPE html>
<html  lang="fr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <style type="text/css">
        p.rubric {
            font-weight: bold;
        }

        p.rubric:hover > a.headerlink {
            visibility: visible;
        }
    </style>
    
      <title>17 Algorithmes et conception</title>
    
      <link rel="stylesheet" href="../_static/pygments.css">
      <link rel="stylesheet" href="../_static/theme.css">
      
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>

      <!-- sphinx script_files -->
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="../_static/translations.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>

      
      <script src="../_static/theme-vendors.js"></script>
      <script src="../_static/theme.js" defer></script>
    
    <link rel="icon" href="../_static/favicon.ico" type="image/x-icon" />
  <link rel="index" title="Index" href="../genindex.html" />
  <link rel="search" title="Recherche" href="../search.html" />
  <link rel="next" title="18 Compilation séparée" href="translation-units.html" />
  <link rel="prev" title="16 Préprocesseur" href="preprocessor.html" /> 
  </head>

  <body>
    <div id="app" class="theme-container" :class="pageClasses"><navbar @toggle-sidebar="toggleSidebar">
  <router-link to="../index.html" class="home-link">
    
      <span class="site-name">Le C pour l&#39;ingenieur</span>
    
  </router-link>

  <div class="links">
    <navlinks class="can-hide">

  
    <div class="nav-item">
      <a href="../index.html#le-c-pour-l-ingenieur"
         class="nav-link  router-link-active">
         Table des matières
      </a>
    </div>
  
    <div class="nav-item">
      <a href="../index.html#le-c-pour-l-ingenieur"
         class="nav-link ">
         Annexes
      </a>
    </div>
  
    <div class="nav-item">
      <a href="../index.html#le-c-pour-l-ingenieur"
         class="nav-link ">
         Références
      </a>
    </div>
  



    </navlinks>
  </div>
</navbar>

      
      <div class="sidebar-mask" @click="toggleSidebar(false)">
      </div>
        <sidebar @toggle-sidebar="toggleSidebar">
          
          <navlinks>
            

  
    <div class="nav-item">
      <a href="../index.html#le-c-pour-l-ingenieur"
         class="nav-link  router-link-active">
         Table des matières
      </a>
    </div>
  
    <div class="nav-item">
      <a href="../index.html#le-c-pour-l-ingenieur"
         class="nav-link ">
         Annexes
      </a>
    </div>
  
    <div class="nav-item">
      <a href="../index.html#le-c-pour-l-ingenieur"
         class="nav-link ">
         Références
      </a>
    </div>
  



            
          </navlinks><div id="searchbox" class="searchbox" role="search">
  <div class="caption"><span class="caption-text">Recherche rapide</span>
    <div class="searchformwrapper">
      <form class="search" action="../search.html" method="get">
        <input type="text" name="q" />
        <input type="submit" value="Recherche" />
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div><div class="sidebar-links" role="navigation" aria-label="main navigation">
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="../index.html#le-c-pour-l-ingenieur">Table des matières</a></span>
      </p>
      <ul class="current">
        
          <li class="toctree-l1 "><a href="introduction.html" class="reference internal ">Introduction</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="programming.html" class="reference internal ">La programmation</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="foundations.html" class="reference internal ">Généralités du langage</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="numeration.html" class="reference internal ">Numération</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="operators.html" class="reference internal ">Opérateurs</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="datatype.html" class="reference internal ">Types de données</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="control-structures.html" class="reference internal ">Structures de contrôle</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="processus.html" class="reference internal ">Programmes et Processus</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="stdio.html" class="reference internal ">Entrées Sorties</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="functions.html" class="reference internal ">Fonctions</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="composite-datatypes.html" class="reference internal ">Types composites</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="files.html" class="reference internal ">Les  fichiers</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="memory-management.html" class="reference internal ">Gestion de la mémoire</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="pointers.html" class="reference internal ">Pointeurs</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="standard-library.html" class="reference internal ">Bibliothèques</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="preprocessor.html" class="reference internal ">Préprocesseur</a>

            
          </li>

        
          <li class="toctree-l1 current"><a href="#" class="reference internal current">Algorithmes et conception</a>

            
              <ul>
                
                  <li class="toctree-l2"><a href="#complexite-d-un-algorithme" class="reference internal">Complexité d'un algorithme</a></li>
                
                  <li class="toctree-l2"><a href="#machines-d-etats" class="reference internal">Machines d'états</a></li>
                
                  <li class="toctree-l2"><a href="#diagrammes-visuels" class="reference internal">Diagrammes visuels</a></li>
                
                  <li class="toctree-l2"><a href="#recursivite" class="reference internal">Récursivité</a></li>
                
                  <li class="toctree-l2"><a href="#programmation-dynamique" class="reference internal">Programmation dynamique</a></li>
                
                  <li class="toctree-l2"><a href="#algorithmes-celebres" class="reference internal">Algorithmes célèbres</a></li>
                
                  <li class="toctree-l2"><a href="#algorithmes-de-tris" class="reference internal">Algorithmes de tris</a></li>
                
                  <li class="toctree-l2"><a href="#type-d-algorithmes" class="reference internal">Type d'algorithmes</a></li>
                
              </ul>
            
          </li>

        
          <li class="toctree-l1 "><a href="translation-units.html" class="reference internal ">Compilation séparée</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="scopes.html" class="reference internal ">Portée et visibilité</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="testing.html" class="reference internal ">Qualité et Testabilité</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="data-structures.html" class="reference internal ">Structures de données</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="advanced-topics.html" class="reference internal ">Avancé</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="traps.html" class="reference internal ">Pièges</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="philosophy.html" class="reference internal ">Philosophie</a>

            
          </li>

        
      </ul>
    </div>
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="../index.html#le-c-pour-l-ingenieur">Annexes</a></span>
      </p>
      <ul class="">
        
          <li class="toctree-l1 "><a href="../appendix/vscode.html" class="reference internal ">Visual Studio Code</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="../appendix/grammar.html" class="reference internal ">Grammaire C</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="../appendix/bash.html" class="reference internal ">Ligne de commande</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="../appendix/development.html" class="reference internal ">Environnement de développement</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="../appendix/unit.html" class="reference internal ">Fiches d'unités de cours</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="../appendix/laboratories.html" class="reference internal ">Laboratoires</a>

            
          </li>

        
      </ul>
    </div>
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="../index.html#le-c-pour-l-ingenieur">Références</a></span>
      </p>
      <ul class="">
        
          <li class="toctree-l1 "><a href="../backmatter/exercises.html" class="reference internal ">Solution des exercices</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="../backmatter/bibliography.html" class="reference internal ">Bibliographie</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="../backmatter/glossary.html" class="reference internal ">Glossaire</a>

            
          </li>

        
      </ul>
    </div>
  
</div>
        </sidebar>

      <page>
          <div class="body-header" role="navigation" aria-label="navigation">
  
  <ul class="breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
    
    <li><span class="section-number">17  </span>Algorithmes et conception</li>
  </ul>
  

  <ul class="page-nav">
  <li class="prev">
    <a href="preprocessor.html"
       title="Chapitre précédent">← <span class="section-number">16  </span>Préprocesseur</a>
  </li>
  <li class="next">
    <a href="translation-units.html"
       title="Chapitre suivant"><span class="section-number">18  </span>Compilation séparée →</a>
  </li>
</ul>
  
</div>
<hr>
          <div class="content" role="main">
            
  <div class="section" id="algorithmes-et-conception">
<span id="algorithms"></span><h1><span class="section-number">17  </span>Algorithmes et conception<a class="headerlink" href="#algorithmes-et-conception" title="Lien permanent vers ce titre">¶</a></h1>
<p>L'algorithmique est le domaine scientifique qui étudie les algorithmes, une suite finie et non ambiguë d'opérations ou d'instructions permettant de résoudre un problème ou de traiter des données.</p>
<p>Un algorithme peut être également considéré comme étant n'importe quelle séquence d'opérations pouvant être simulées par un système <a class="reference external" href="https://fr.wikipedia.org/wiki/Turing-complet">Turing-complet</a>. Un système est déclaré Turing-complet s'il peut simuler n'importe quelle <a class="reference external" href="https://fr.wikipedia.org/wiki/Machine_de_Turing">machine de Turing</a>. For heureusement, le langage C est Turing-complet puisqu'il possède tous les ingrédients nécessaires à la simulation de ces machines, soit compter, comparer, lire, écrire...</p>
<p>Dans le cas qui concerne cet ouvrage, un algorithme est une recette exprimée en une liste d'instructions et permettant de résoudre un problème informatique. Cette recette contient à peu de choses près les éléments programmatiques que nous avons déjà entre aperçus: des structures de contrôle, des variables, etc.</p>
<p>Généralement un algorithme peut être exprimé graphiquement en utilisant un organigramme (<em>flowchart</em>) ou un structogramme (<em>Nassi-Shneiderman diagram</em>) afin de s'affranchir du langage de programmation cible.</p>
<p>La <strong>conception</strong> aussi appelée <a class="reference external" href="https://fr.wikipedia.org/wiki/Architecture_logicielle">Architecture logicielle</a> est l'art de penser un programme avant son implémentation. La phase de conception fait bien souvent appel à des algorithmes.</p>
<p>Pour être qualifiées d'algorithmes, certaines propriétés doivent être respectées :</p>
<ol class="arabic simple">
<li><p><strong>Entrées</strong>, un algorithme doit posséder 0 ou plus d'entrées en provenance de l'extérieur de l'algorithme.</p></li>
<li><p><strong>Sorties</strong>, un algorithme doit posséder au moins une sortie.</p></li>
<li><p><strong>Rigueur</strong>, chaque étape d'un algorithme doit être claire et bien définie.</p></li>
<li><p><strong>Finitude</strong>, un algorithme doit comporter un nombre fini d'étapes.</p></li>
<li><p><strong>Répétable</strong>, un algorithme doit fournir un résultat répétable.</p></li>
</ol>
<div class="section" id="complexite-d-un-algorithme">
<h2><span class="section-number">17.1  </span>Complexité d'un algorithme<a class="headerlink" href="#complexite-d-un-algorithme" title="Lien permanent vers ce titre">¶</a></h2>
<p>Il est souvent utile de savoir quelle est la complexité d'un algorithme afin de le comparer à un autre algorithme équivalent. Il existe deux indicateurs :</p>
<ul class="simple">
<li><p>La complexité en temps</p></li>
<li><p>La complexité en mémoire</p></li>
</ul>
<p>Pour l'un, l'idée est de savoir combine de temps CPU consomme un algorithme. Pour l'autre, on s'intéresse à l'utilisation de mémoire tampon.</p>
<p>La complexité en temps et en mémoire d'un algorithme est souvent exprimée en utilisant la notation en O (<em>big O notation</em>). Par exemple, la complexité en temps d'un algorithme qui demanderait 10 étapes pour être résolu s'écrirait :</p>
<div class="math notranslate nohighlight">
\[O(10)\]</div>
<p>Un algorithme qui ferait une recherche dichotomique sur un tableau de <span class="math notranslate nohighlight">\(n\)</span> éléments à une complexité <span class="math notranslate nohighlight">\(O(log(n))\)</span>.</p>
<p>Quelques points à retenir :</p>
<ul class="simple">
<li><p>La complexité d'un algorithme considère toujours le cas le moins favorable.</p></li>
<li><p>Le meilleur algorithme est celui qui présente le meilleur compromis entre sa complexité en temps et sa complexité en mémoire.</p></li>
</ul>
<p>À titre d'exemple, le programme suivant qui se charge de remplacer les valeurs paires d'un tableau par un 0 et les valeurs impaires par un 1 à une complexité en temps de <span class="math notranslate nohighlight">\(O(n)\)</span> où <code class="docutils literal notranslate"><span class="pre">n</span></code> est le
nombre d'éléments du tableau.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">discriminate</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">array</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>D'une manière générale, la plupart des algorithmes que l'ingénieur écrira appartiendront à ces
catégories exprimées du meilleur au plus mauvais :</p>
<table class="docutils align-default" id="id1">
<caption><span class="caption-number">Tableau 17.1 </span><span class="caption-text">Temps pour différentes complexités d'algorithmes</span><a class="headerlink" href="#id1" title="Lien permanent vers ce tableau">¶</a></caption>
<colgroup>
<col style="width: 27%" />
<col style="width: 24%" />
<col style="width: 49%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Complexité</p></th>
<th class="head"><p><span class="math notranslate nohighlight">\(n = 100000\)</span></p></th>
<th class="head"><p>i7 (100'000 MIPS)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(O(log(n))\)</span></p></td>
<td><p>11</p></td>
<td><p>0.11 ns</p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(O(n)\)</span></p></td>
<td><p>100'000</p></td>
<td><p>1 us</p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(O(n log(n))\)</span></p></td>
<td><p>1'100'000</p></td>
<td><p>11 us</p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(O(n^2)\)</span></p></td>
<td><p>10'000'000'000</p></td>
<td><p>100 ms (un battement de cil)</p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(O(2^n)\)</span></p></td>
<td><p>très très grand</p></td>
<td><p>Le soleil devenu géante rouge
aura ingurgité la terre</p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(O(n!)\)</span></p></td>
<td><p>trop trop grand</p></td>
<td><p>La galaxie ne sera plus que poussière</p></td>
</tr>
</tbody>
</table>
<p>Les différentes complexités peuvent être résumées sur la figure suivante :</p>
<div class="figure align-default" id="id2">
<img alt="../_images/complexity.svg" src="../_images/complexity.svg" /><p class="caption"><span class="caption-number">Fig. 17.1 </span><span class="caption-text">Différentes complexités d'algorithmes</span><a class="headerlink" href="#id2" title="Lien permanent vers cette image">¶</a></p>
</div>
<p>Un algorithme en <span class="math notranslate nohighlight">\(O(n^2)\)</span>, doit éveiller chez le développeur la volonté de voir s'il n'y a pas moyen d'optimiser l'algorithme en réduisant sa complexité, souvent on s'aperçoit qu'un algorithme peut être optimisé et s'intéresser à sa complexité est un excellent point d'entrée.</p>
<p>Attention toutefois à ne pas mal évaluer la complexité d'un algorithme. Voyons par exemple les deux algorithmes suivants :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">MAX_INT</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">MIN_INT</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">min</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">min</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">max</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">MAX_INT</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">MIN_INT</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">min</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">min</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">max</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div>
<p class="rubric">Exercice 17.1<a class="headerlink" href="#exercise-0" title="Permalink to this rubric">¶</a></p>
<p>Quel serait l'algorithme permettant d'afficher :</p>
<p>et dont la taille peut varier ?</p>
</div>
<div>
<p class="rubric">Exercice 17.2<a class="headerlink" href="#exercise-1" title="Permalink to this rubric">¶</a></p>
<p>On vous donne un gros fichier de 3'000'000'000 entiers positifs 32-bits, il vous faut générer un entier qui n'est pas dans la liste. Le hic, c'est que vous n'avez que 500 MiB de mémoire de travail. Quel algorithme proposez-vous ?</p>
<p>Une fois le travail terminé, votre manager vient vous voir pour vous annoncer que le cahier des charges a été modifié. Le client dit qu'il n'a que 10 MiB. Pensez-vous pouvoir résoudre le problème quand même ?</p>
</div>
</div>
<div class="section" id="machines-d-etats">
<h2><span class="section-number">17.2  </span>Machines d'états<a class="headerlink" href="#machines-d-etats" title="Lien permanent vers ce titre">¶</a></h2>
</div>
<div class="section" id="diagrammes-visuels">
<h2><span class="section-number">17.3  </span>Diagrammes visuels<a class="headerlink" href="#diagrammes-visuels" title="Lien permanent vers ce titre">¶</a></h2>
<ul class="simple">
<li><p>Diagrammes en flux</p></li>
<li><p>Structogrammes</p></li>
<li><p>Diagramme d'activités</p></li>
<li><p>Machines d'états (<a class="reference external" href="https://en.wikipedia.org/wiki/UML_state_machine">UML state machine</a>)</p></li>
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Business_Process_Model_and_Notation">BPMN</a> (<em>Business Process Model and Notation</em>)</p></li>
</ul>
</div>
<div class="section" id="recursivite">
<h2><span class="section-number">17.4  </span>Récursivité<a class="headerlink" href="#recursivite" title="Lien permanent vers ce titre">¶</a></h2>
<p>La <a class="reference external" href="https://fr.wikipedia.org/wiki/R%C3%A9cursivit%C3%A9">récursivité</a> est une autoréférence. Il peut s'agit en C d'une fonction qui s'appelle elle-même.</p>
<div>
<p class="rubric">Exercice 17.3<a class="headerlink" href="#exercise-2" title="Permalink to this rubric">¶</a></p>
<p>Soit deux tableaux d'entiers, trouver la paire de valeurs (une dans chaque tableau) ayant la plus petite différence (positive).</p>
<p>Exemple :</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>int a[] = {5, 3, 14, 11, 2};
int b[] = {24, 128, 236, 20, 8};

int diff = 3 // pair 11, 8
</pre></div>
</div>
<ol class="arabic simple">
<li><p>Proposer une implémentation</p></li>
<li><p>Quelle est la complexité de votre algorithme ?</p></li>
</ol>
</div>
</div>
<div class="section" id="programmation-dynamique">
<h2><span class="section-number">17.5  </span>Programmation dynamique<a class="headerlink" href="#programmation-dynamique" title="Lien permanent vers ce titre">¶</a></h2>
<p>La programmation dynamique est une méthode algorithmique datant des années 1950, mais devenue populaire ces dernières années. Elle permet de coupler des algorithmes récursifs avec le concept de mémoïsation.</p>
<p>Prenons par exemple l'algorithme de Fibonacci récursif :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Le problème de cet algorithme est sa performance. Appeler <code class="docutils literal notranslate"><span class="pre">fibonacci(50)</span></code> demandera de calculer <code class="docutils literal notranslate"><span class="pre">fibonacci(49)</span></code> et <code class="docutils literal notranslate"><span class="pre">fibonacci(48)</span></code> mais pour calculer <code class="docutils literal notranslate"><span class="pre">fibonacci(49)</span></code> il faudra recalculer <code class="docutils literal notranslate"><span class="pre">fibonacci(48)</span></code>. On voit qu'on effectue du travail à double. En réalité c'est bien pire que ça. La complexité est de <span class="math notranslate nohighlight">\(O(2^n)\)</span>. Donc pour calculer la valeur <code class="docutils literal notranslate"><span class="pre">50</span></code> il faudra effectuer <span class="math notranslate nohighlight">\(1 125 899 906 842 624\)</span> opérations. Avec un ordinateur capable de calculer 1 milliard d'opérations par seconde, il faudra tout de même plus d'un million de secondes. Cet algorithme est donc très mauvais !</p>
<p>En revanche, si l'on est capable de mémoriser dans une table les résultats précédents des appels de Fibonacci, les performances seront bien meilleures.</p>
<p>Voici l'algorithme modifié :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">memo</span><span class="p">[</span><span class="mi">1000</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">memo</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="k">return</span> <span class="n">memo</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">memo</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Sa complexité est ainsi réduite à <span class="math notranslate nohighlight">\(O(2\cdot n)\)</span> et donc <span class="math notranslate nohighlight">\(O(n)\)</span>. En revanche, l'approche dynamique demande un espace mémoire supplémentaire. On n'a rien sans rien et l'éternel dilemme mémoire versus performance s'applique toujours.</p>
</div>
<div class="section" id="algorithmes-celebres">
<h2><span class="section-number">17.6  </span>Algorithmes célèbres<a class="headerlink" href="#algorithmes-celebres" title="Lien permanent vers ce titre">¶</a></h2>
<div class="section" id="exponentiation-rapide">
<h3><span class="section-number">17.6.1  </span>Exponentiation rapide<a class="headerlink" href="#exponentiation-rapide" title="Lien permanent vers ce titre">¶</a></h3>
<p>Cet algorithme permet de calculer rapidement des puissances entières (<span class="math notranslate nohighlight">\(a^n\)</span>). La méthode naïve consiste à calculer les puissances avec une boucle :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">long</span> <span class="kt">long</span> <span class="n">pow</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">a</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">a</span> <span class="o">*=</span> <span class="n">a</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>La complexité de cet algorithme est <span class="math notranslate nohighlight">\(O(n)\)</span>. Il est possible de faire mieux en <span class="math notranslate nohighlight">\(O(n log n)\)</span>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">long</span> <span class="kt">long</span> <span class="n">bin_pow</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">a</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">res</span> <span class="o">=</span> <span class="n">bin_pow</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">res</span> <span class="o">*</span> <span class="n">res</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">?</span> <span class="nl">a</span> <span class="p">:</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Comme évoqué plus haut, un algorithme récursif est souvent moins performant que sa variante itérative. Voici l'implémentation itérative :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">long</span> <span class="kt">long</span> <span class="n">bin_pow</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">a</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">*</span> <span class="n">a</span><span class="p">;</span>
        <span class="n">a</span> <span class="o">*=</span> <span class="n">a</span><span class="p">;</span>
        <span class="n">b</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="racine-carree-inverse-rapide">
<h3><span class="section-number">17.6.2  </span>Racine carrée inverse rapide<a class="headerlink" href="#racine-carree-inverse-rapide" title="Lien permanent vers ce titre">¶</a></h3>
<p>Cet algorithme a été développé chez Silicon Graphics au début des années 90. Il a été utilisé dans des jeux vidéos comme <a class="reference external" href="https://fr.wikipedia.org/wiki/Quake_III_Arena">Quake III Arena</a> pour améliorer la performance du calcul des angles d'incidence dans la réflexion des lumières.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span> <span class="nf">Q_rsqrt</span><span class="p">(</span><span class="kt">float</span> <span class="n">number</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">float</span> <span class="n">threehalfs</span> <span class="o">=</span> <span class="mf">1.5F</span><span class="p">;</span>

    <span class="kt">float</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">number</span> <span class="o">*</span> <span class="mf">0.5F</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">y</span> <span class="o">=</span> <span class="n">number</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">;</span> <span class="c1">// Evil floating point bit level hacking</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mh">0x5f3759df</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// What the fuck?</span>
    <span class="n">y</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">float</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">*</span> <span class="p">(</span><span class="n">threehalfs</span> <span class="o">-</span> <span class="p">(</span><span class="n">x2</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span><span class="p">));</span> <span class="c1">// 1st iteration</span>
<span class="cp">#if BETTER</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">*</span> <span class="p">(</span><span class="n">threehalfs</span> <span class="o">-</span> <span class="p">(</span><span class="n">x2</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span><span class="p">));</span> <span class="c1">// 2nd iteration</span>
<span class="cp">#endif</span>
    <span class="k">return</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Cet algorithme de <a class="reference external" href="https://fr.wikipedia.org/wiki/Racine_carr%C3%A9e_inverse_rapide">racine carrée inverse rapide</a> utilise une constante magique <code class="docutils literal notranslate"><span class="pre">0x5f3759df</span></code>. L'implémentation proposée ci-dessus est extraite du code source du jeu Quake III arena (<a class="reference external" href="https://github.com/id-Software/Quake-III-Arena/blob/dbe4ddb10315479fc00086f08e25d968b4b43c49/code/game/q_math.c#L552">q_math.c</a>) disponible sur GitHub.</p>
<p>Ce n'est pas un algorithme très académique, il s'agit d'un <a class="reference external" href="https://fr.wikipedia.org/wiki/Kludge">kludge</a>, une solution irrespectueuse des règles de l'art de la programmation, car la valeur <code class="docutils literal notranslate"><span class="pre">y</span></code> est transtypée en un <code class="docutils literal notranslate"><span class="pre">long</span></code> (<code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">=</span> <span class="pre">*(long</span> <span class="pre">*)&amp;y</span></code>. C'est cette astuce qui permet de tirer avantage que les valeurs en virgule flottantes sont exprimées en puissances de 2.</p>
</div>
<div class="section" id="algorithme-de-rabin-karp">
<h3><span class="section-number">17.6.3  </span>Algorithme de Rabin-Karp<a class="headerlink" href="#algorithme-de-rabin-karp" title="Lien permanent vers ce titre">¶</a></h3>
<p>Cet algorithme <a class="reference external" href="https://fr.wikipedia.org/wiki/Algorithme_de_Rabin-Karp">Rabin-Karp</a> permet la recherche d'une sous-chaîne de caractère. Sa complexité moyenne est <span class="math notranslate nohighlight">\(O(n + m)\)</span>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>

<span class="cp">#define CHARS_IN_ALPHABET 256</span>

<span class="cm">/**</span>
<span class="cm"> * Rabin-Karp algorithm</span>
<span class="cm"> * @param needle Motif à rechercher</span>
<span class="cm"> * @param haystack Texte d&#39;entrée</span>
<span class="cm"> * @param matches La liste des occurences trouvées</span>
<span class="cm"> * @param size La taille du tableau matches</span>
<span class="cm"> * @return Le nombre d&#39;occurences trouvées</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">search</span><span class="p">(</span><span class="kt">char</span> <span class="n">needle</span><span class="p">[],</span> <span class="kt">char</span> <span class="n">haystack</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">matches</span><span class="p">[],</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">q</span> <span class="o">=</span> <span class="mi">101</span><span class="p">;</span> <span class="c1">// A prime number</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">M</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">needle</span><span class="p">);</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">haystack</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">M</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">h</span> <span class="o">*</span> <span class="n">CHARS_IN_ALPHABET</span><span class="p">)</span> <span class="o">%</span> <span class="n">q</span><span class="p">;</span>

    <span class="c1">// Compute the hash value of pattern and first</span>
    <span class="c1">// window of text</span>
    <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Hash value for pattern</span>
    <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Hash value for haystack</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">CHARS_IN_ALPHABET</span> <span class="o">*</span> <span class="n">p</span> <span class="o">+</span> <span class="n">needle</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">%</span> <span class="n">q</span><span class="p">;</span>
        <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">CHARS_IN_ALPHABET</span> <span class="o">*</span> <span class="n">t</span> <span class="o">+</span> <span class="n">haystack</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">%</span> <span class="n">q</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Slide the pattern over text one by one</span>
    <span class="kt">size_t</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">N</span> <span class="o">-</span> <span class="n">M</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Check the hash values of current window of text</span>
        <span class="c1">// and pattern. If the hash values match then only</span>
        <span class="c1">// check for characters on by one</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">t</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// Check for characters one by one</span>
            <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">haystack</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">needle</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">)</span>
                <span class="n">j</span><span class="o">++</span><span class="p">;</span>

            <span class="c1">// Save the position found</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">M</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">)</span>
                    <span class="n">matches</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
                <span class="k">else</span>
                    <span class="k">return</span> <span class="n">k</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// Calculate hash value for next window of text.</span>
        <span class="c1">// Remove leading digit and add trailing digit.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">M</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">CHARS_IN_ALPHABET</span> <span class="o">*</span>
                <span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">haystack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">h</span><span class="p">)</span> <span class="o">+</span> <span class="n">haystack</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">M</span><span class="p">])</span> <span class="o">%</span> <span class="n">q</span><span class="p">;</span>
            <span class="n">t</span> <span class="o">+=</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="nl">q</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">k</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">test_search</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">text</span><span class="p">[]</span> <span class="o">=</span>
        <span class="s">&quot;Le courage n&#39;est pas l&#39;absence de peur, &quot;</span>
        <span class="s">&quot;mais la capacité de vaincre ce qui fait peur.&quot;</span>
        <span class="s">&quot;On ne peut vaincre sa destinée.&quot;</span>
        <span class="s">&quot;A vaincre sans barils, on triomphe sans boire.&quot;</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">matches</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">search</span><span class="p">(</span><span class="s">&quot;vaincre&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">matches</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">matches</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">matches</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">61</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">matches</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">97</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">matches</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">120</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">test_search</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="algorithmes-de-tris">
<h2><span class="section-number">17.7  </span>Algorithmes de tris<a class="headerlink" href="#algorithmes-de-tris" title="Lien permanent vers ce titre">¶</a></h2>
<div class="section" id="heap-sort">
<h3><span class="section-number">17.7.1  </span>Heap Sort<a class="headerlink" href="#heap-sort" title="Lien permanent vers ce titre">¶</a></h3>
<p>L'algorithme <a class="reference external" href="https://fr.wikipedia.org/wiki/Tri_par_tas">Heap Sort</a> aussi appelé &quot;Tri par tas&quot; est l'un des algorithmes de tri les plus performants offrant une complexité en temps de <span class="math notranslate nohighlight">\(O(n\cdot log(n))\)</span> et une complexité en espace de <span class="math notranslate nohighlight">\(O(1)\)</span>. Il s'appuie sur le concept d'arbre binaire.</p>
<p>Prenons l'exemple du tableau ci-dessous et deux règles suivantes :</p>
<ul class="simple">
<li><p>l'enfant de gauche est donné par <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">k</span> <span class="pre">+</span> <span class="pre">1</span></code> ;</p></li>
<li><p>l'enfant de droite est donné par <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">k</span> <span class="pre">+</span> <span class="pre">2</span></code>.</p></li>
</ul>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>  1   2       3                  4
┞──╀──┬──╀──┬──┬──┬──╀──┬──┬──┬──┬──┬──┬──┬──┦
│08│04│12│20│06│42│14│11│03│35│07│09│11│50│16│
└──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘
  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  (indice)
</pre></div>
</div>
<p>La première valeur du tableau est appelée la racine <em>root</em>. C'est le premier élément de l'arbre. Puisqu'il s'agit d'un arbre binaire, chaque noeud peut comporter jusqu'à 2 enfants. L'enfant de gauche est calculé à partir de l'indice <code class="docutils literal notranslate"><span class="pre">k</span></code> de l'élément courant. Ainsi les deux enfants de l'élément <code class="docutils literal notranslate"><span class="pre">4</span></code> seront <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">4</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">=</span> <span class="pre">9</span></code> et <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">4</span> <span class="pre">+</span> <span class="pre">2</span> <span class="pre">==</span> <span class="pre">a</span></code>.</p>
<p>Ce tableau linéaire en mémoire pourra être représenté visuellement comme un arbre binaire :</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>             8
             |
         ----+----
       /           \
      4            12
   /    \        /    \
  20     6      42    14
 / \    / \    / \   /  \
11  3  35  7  9  11 50  16
</pre></div>
</div>
<p>Le coeur de cet algorithme est le sous-algorithme nommé <em>heapify</em>. Ce dernier à pour objectif de satisfaire une exigence supplémentaire de notre arbre : <strong>chaque enfant doit être plus petit que son parent</strong>. Le principe est donc simple. On part du dernier élément de l'arbre qui possède au moins un enfant : la valeur <code class="docutils literal notranslate"><span class="pre">14</span></code> (indice <code class="docutils literal notranslate"><span class="pre">6</span></code>). Le plus grand des enfants est échangé avec la valeur du parent. Ici <code class="docutils literal notranslate"><span class="pre">50</span></code> sera échangé avec <code class="docutils literal notranslate"><span class="pre">14</span></code>. Ensuite on applique récursivement ce même algorithme pour tous les enfants qui ont été échangés. Comme <code class="docutils literal notranslate"><span class="pre">14</span></code> (anciennement <code class="docutils literal notranslate"><span class="pre">50</span></code>) n'a pas d'enfant, on s'arrête là.</p>
<p>L'algorithme continue en remontant jusqu'à la racine de l'arbre. La valeur suivante analysée est donc <code class="docutils literal notranslate"><span class="pre">42</span></code>, comme les deux enfants sont petits on continue avec la valeur <code class="docutils literal notranslate"><span class="pre">6</span></code>. Cette fois-ci <code class="docutils literal notranslate"><span class="pre">35</span></code> qui est plus grand est alors échangé. Comme <code class="docutils literal notranslate"><span class="pre">6</span></code> n'a plus d'enfant, on continue avec <code class="docutils literal notranslate"><span class="pre">20</span></code>, puis <code class="docutils literal notranslate"><span class="pre">12</span></code>. À cette étape, notre arbre ressemble à ceci :</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>             8
             |
         ----+----
       /           \
      4            12
   /    \        /    \
  20    35      42    50
 / \    / \    / \   /  \
11  3  6   7  9  11 14  16
</pre></div>
</div>
<p>La valeur <code class="docutils literal notranslate"><span class="pre">12</span></code> est plus petite que <code class="docutils literal notranslate"><span class="pre">50</span></code> et est donc échangée. Mais puisque <code class="docutils literal notranslate"><span class="pre">12</span></code> contient deux enfants (<code class="docutils literal notranslate"><span class="pre">14</span></code> et <code class="docutils literal notranslate"><span class="pre">16</span></code>), l'algorithme continue. <code class="docutils literal notranslate"><span class="pre">16</span></code> est échangé avec <code class="docutils literal notranslate"><span class="pre">12</span></code>. L'algorithme se poursuit avec <code class="docutils literal notranslate"><span class="pre">4</span></code> et se terminera avec la racine <code class="docutils literal notranslate"><span class="pre">8</span></code>. Finalement l'arbre ressemblera à ceci :</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>            35
             |
         ----+----
       /           \
     20            50
   /    \        /    \
  11     7      42    16
 / \    / \    / \   /  \
8   3  6   4  9  11 14  12
</pre></div>
</div>
<p>On peut observer que chaque noeud de l'arbre satisfait à l'exigence susmentionnée : tous les enfants sont inférieurs à leurs parents.</p>
<p>Une fois que cette propriété est respectée, on a l'assurance que la racine de l'arbre est maintenant le plus grand élément du tableau. Il est alors échangé avec le dernier élément du tableau <code class="docutils literal notranslate"><span class="pre">12</span></code>, qui devient à son tour la racine.</p>
<p>Le dernier élément est sorti du tableau et notre arbre ressemble maintenant à ceci :</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>1   2       3                  4
┞──╀──┬──╀──┬──┬──┬──╀──┬──┬──┬──┬──┬──┬──┦──┦
│12│20│50│11│ 7│42│16│ 8│ 3│ 6│ 4│ 9│11│14│35│
└──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘
  0  1  2  3  4  5  6  7  8  9  a  b  c  d     (indice)

            12
             |
         ----+----
       /           \
     20            50
   /    \        /    \
  11     7      42    16
 / \    / \    / \   /
8   3  6   4  9  11 14
</pre></div>
</div>
<p>À ce moment on recommence :</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">heapify</span></code></p></li>
<li><p>Échange du premier élément avec le dernier.</p></li>
<li><p>Sortie du dernier élément de l'arbre.</p></li>
<li><p>Retour à (1) jusqu'à ce que tous les éléments soient sortis de l'arbre.</p></li>
</ol>
</div>
<div class="section" id="quick-sort">
<h3><span class="section-number">17.7.2  </span>Quick Sort<a class="headerlink" href="#quick-sort" title="Lien permanent vers ce titre">¶</a></h3>
<p>Le <a class="reference external" href="https://fr.wikipedia.org/wiki/Tri_rapide">tri rapide</a> est l'algorithme de tri par référence dans la plupart des langage de programmation. Selon le compilateur C que vous utilisez, la fonction <code class="docutils literal notranslate"><span class="pre">qsort</span></code> implémente cette méthode de tri en <span class="math notranslate nohighlight">\(O(n log n)\)</span>.</p>
<p>Quick sort est théoriquement plus lent que le Heap sort avec dans le pire des cas en <span class="math notranslate nohighlight">\(O(n^2)\)</span>. Néanmoins, en s'appuyant que cette <a class="reference external" href="https://stackoverflow.com/a/1853219/2612235">réponse</a> StackOverflow, quick sort reste meilleur pour de grands tableaux car les embranchements sont moins fréquents, et le cache processeur est donc mieux utilisé.</p>
<p>Cet algorithme utilise la notion de <strong>pivot</strong>. Le pivot est un élément qui est choisi pour être le point autour duquel sont agencé les éléments. La méthode de tri est la suivante :</p>
<ol class="arabic simple">
<li><p>Choix d'un pivot</p></li>
<li><p>Paritionnement : tous les éléments plus petit que le pivot sont déplacé à gauche et tous les éléments plus grands sont à droite. L'élément pivot est ainsi positionné à sa bonne place dans le tableau.</p></li>
<li><p>Appel récursif pour la partie gauche et droite.</p></li>
</ol>
<p>Considérons le tableau suivant. Les valeurs ne sont pas triées. La première étape consiste à choisir un pivot. Il existe plusieurs technique :</p>
<ul class="simple">
<li><p>Choisir le premier élément comme pivot</p></li>
<li><p>Choisir le dernier élément comme pivot</p></li>
<li><p>Choisir l'élément médian comme pivot</p></li>
</ul>
<p>Dans cet exemple, le dernier élément <code class="docutils literal notranslate"><span class="pre">6</span></code> sera arbitrairement choisi comme pivot.</p>
<div class="figure align-default" id="id3">
<a class="reference internal image-reference" href="../_images/quicksort.svg"><img alt="../_images/quicksort.svg" src="../_images/quicksort.svg" /></a>
<p class="caption"><span class="caption-number">Fig. 17.2 </span><span class="caption-text">Représentation du tableau à trier avec son pivot.</span><a class="headerlink" href="#id3" title="Lien permanent vers cette image">¶</a></p>
</div>
<p>L'étape de paritionnement utilise l'algorithme suivant :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">partition</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">low</span><span class="p">,</span> <span class="kt">int</span> <span class="n">high</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pivot</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">low</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">low</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">high</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">[</span><span class="n">pivot</span><span class="p">])</span>
            <span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
    <span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">pivot</span><span class="p">]);</span>
    <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Voici comment <code class="docutils literal notranslate"><span class="pre">partition(a,</span> <span class="pre">0,</span> <span class="pre">10,</span> <span class="pre">10)</span></code> modifie le tableau (voir <a class="reference external" href="../../assets/src/partition.c">code source</a>) :</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>2 9 4 1 b 5 a 7 3 8 6
2 4 9 1 b 5 a 7 3 8 6
2 4 1 9 b 5 a 7 3 8 6
2 4 1 5 b 9 a 7 3 8 6
2 4 1 5 3 9 a 7 b 8 6
2 4 1 5 3 6 a 7 b 8 9
</pre></div>
</div>
<p>On constate que la valeur <cite>6</cite> choisie comme pivot est maintenant à sa bonne place. L'algorithme est donc appelé récursivement pour les éléments <code class="docutils literal notranslate"><span class="pre">0</span></code> à <code class="docutils literal notranslate"><span class="pre">4</span></code> et `` 6``  à <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<div class="figure align-default" id="id4">
<a class="reference internal image-reference" href="../_images/quicksort-2.svg"><img alt="../_images/quicksort-2.svg" src="../_images/quicksort-2.svg" /></a>
<p class="caption"><span class="caption-number">Fig. 17.3 </span><span class="caption-text">Tri rapide après le premier partitionnement.</span><a class="headerlink" href="#id4" title="Lien permanent vers cette image">¶</a></p>
</div>
<p>Voici une autre représentation (voir <a class="reference external" href="../../assets/src/quicksort.c">code source</a>) :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span>  <span class="mi">9</span>  <span class="mi">5</span>  <span class="mi">2</span>  <span class="n">b</span>  <span class="mi">4</span>  <span class="n">a</span>  <span class="mi">7</span>  <span class="mi">3</span>  <span class="mi">8</span> <span class="p">[</span><span class="mi">6</span><span class="p">]</span>
<span class="mi">1</span>  <span class="mi">5</span>  <span class="mi">2</span>  <span class="mi">4</span>  <span class="mi">3</span> <span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="n">a</span>  <span class="mi">7</span>  <span class="n">b</span>  <span class="mi">8</span>  <span class="mi">9</span>
<span class="mi">1</span>  <span class="mi">5</span>  <span class="mi">2</span>  <span class="mi">4</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="mi">1</span>  <span class="mi">2</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="mi">4</span>  <span class="mi">5</span>
<span class="mi">1</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="mi">1</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="mi">4</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span>
        <span class="mi">4</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span>
                <span class="n">a</span>  <span class="mi">7</span>  <span class="n">b</span>  <span class="mi">8</span> <span class="p">[</span><span class="mi">9</span><span class="p">]</span>
                <span class="mi">7</span>  <span class="mi">8</span> <span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="n">a</span>  <span class="n">b</span>
                <span class="mi">7</span> <span class="p">[</span><span class="mi">8</span><span class="p">]</span>
                <span class="mi">7</span> <span class="p">[</span><span class="mi">8</span><span class="p">]</span>
                        <span class="n">a</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
                        <span class="n">a</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="type-d-algorithmes">
<h2><span class="section-number">17.8  </span>Type d'algorithmes<a class="headerlink" href="#type-d-algorithmes" title="Lien permanent vers ce titre">¶</a></h2>
<div class="section" id="algorithmes-en-ligne-incremental">
<h3><span class="section-number">17.8.1  </span>Algorithmes en ligne (incrémental)<a class="headerlink" href="#algorithmes-en-ligne-incremental" title="Lien permanent vers ce titre">¶</a></h3>
<p>Un algorithme incrémental ou <a class="reference external" href="https://fr.wikipedia.org/wiki/Algorithme_online">online</a> est un algorithme qui peut s'exécuter sur un flux de données continu en entrée. C'est-à-dire qu'il est en mesure de prendre des décisions sans avoir besoin d'une visibilité complète sur le set de données.</p>
<p>Un exemple typique est le <a class="reference external" href="https://fr.wikipedia.org/wiki/Probl%C3%A8me_du_secr%C3%A9taire">problème de la secrétaire</a>. On souhaite recruter une nouvelle secrétaire et le recruteur voit défiler les candidats. Il doit décider à chaque entretien s'il engage ou non le candidat et ne peut pas attendre la fin du processus d'entretiens pour obtenir le score attribué à chaque candidat. Il ne peut comparer la performance de l'un qu'à celle de deux déjà entrevus. L'objectif est de trouver la meilleure stratégie.</p>
<p>La solution à ce problème est de laisser passer 37% des candidats sans les engager. Ceci correspond à une proportion de <span class="math notranslate nohighlight">\(1/e\)</span>. Ensuite il suffit d'attendre un ou une candidate meilleure que tous ceux/celles du premier échantillon.</p>
<hr class="docutils" />
<div>
<p class="rubric">Exercice 17.4<a class="headerlink" href="#exercise-3" title="Permalink to this rubric">¶</a></p>
<p>L'intégrateur de Kahan (<a class="reference external" href="https://en.wikipedia.org/wiki/Kahan_summation_algorithm">Kahan summation algorithm</a>) est une solution élégante pour pallier à la limite de résolution des types de données.</p>
<p>L'algorithme pseudo-code peut être exprimé comme :</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>function kahan_sum(input)
    var sum = 0.0
    var c = 0.0
    for i = 1 to input.length do
        var y = input[i] - c
        var t = sum + y
        c = (t - sum) - y
        sum = t
    next i
    return sum
</pre></div>
</div>
<ol class="arabic">
<li><p>Implémenter cet algorithme en C compte tenu du prototype :</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span> <span class="nf">kahan_sum</span><span class="p">(</span><span class="kt">float</span> <span class="n">value</span><span class="p">,</span> <span class="kt">float</span> <span class="n">sum</span><span class="p">,</span> <span class="kt">float</span> <span class="n">c</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>Expliquer comment fonctionne cet algorithme.</p></li>
<li><p>Donner un exemple montrant l'avantage de cet algorithme sur une simple somme.</p></li>
</ol>
</div>
<div>
<p class="rubric">Exercice 17.5<a class="headerlink" href="#exercise-4" title="Permalink to this rubric">¶</a></p>
<p>Un robot aspirateur souhaite se rassasier et cherche le frigo, le problème c'est qu'il ne sait pas où il est. Elle serait la stratégie de recherche du robot pour se rendre à la cuisine ?</p>
<p>Le robot dispose de plusieurs fonctionnalités :</p>
<ul class="simple">
<li><p>Avancer</p></li>
<li><p>Tourner à droite de 90°</p></li>
<li><p>Détection de sa position absolue p. ex. <code class="docutils literal notranslate"><span class="pre">P5</span></code></p></li>
</ul>
<p>Élaborer un algorithme de recherche.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  │ A │ B │ C │ D │ E │ F │ G │ H │ I │ J │ K │ L │ M │ O │ P │ Q │
──┏━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━┳━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┓
1 ┃                     x ┃       ┃               ┃               ┃
──┃             F1: Frigo ┃       ┃               ┃               ┃
2 ┃       ┃               ┃       ┃               ┃               ┃
──┃       ┃               ┃       ┃               ┃               ┃
3 ┃       ┃               ┃       ┃               ┃               ┃
──┃       ┃               ┃       ┃               ┃               ┃
4 ┃       ┃               ┃       ┃               ┃               ┃
──┃       ┃               ┃       ┃               ┃               ┃
5 ┃       ┃               ┃       ┃               ┃      &lt;--o     ┃
──┃       ┣━━━━━━━   ━━━━━┫       ┃               ┃     P5: Robot ┃
6 ┃       ┃               ┃       ┃               ┃               ┃
──┃       ┃               ┃       ┃               ┃               ┃
7 ┃                       ┃       ┃               ┃               ┃
──┃                       ┃       ┃               ┃               ┃
8 ┃       ┃               ┃       ┃               ┃               ┃
──┣━━━━━━━┻━━━━━━━    ━━━━┛   ━━━━┛   ━━━━━━━━━━━━┛   ━━━━┳━━━━━━━┫
9 ┃                                                       ┃       ┃
──┃                                                       ┃       ┃
10┃                                                               ┃
──┃                                                               ┃
11┃                                                       ┃       ┃
──┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┻━━━━━━━┛
</pre></div>
</div>
</div>
</div>
</div>
</div>


          </div>
          <div class="page-nav">
            <div class="inner"><ul class="page-nav">
  <li class="prev">
    <a href="preprocessor.html"
       title="Chapitre précédent">← <span class="section-number">16  </span>Préprocesseur</a>
  </li>
  <li class="next">
    <a href="translation-units.html"
       title="Chapitre suivant"><span class="section-number">18  </span>Compilation séparée →</a>
  </li>
</ul><div class="footer" role="contentinfo">
      &#169; Copyright HEIG-VD(c) 2021.
    Mis à jour le 30 mai 2021 (version v0.3.0-22-gff14f86).
    <br>
    Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.2.1 with <a href="https://github.com/heig-vd-tin/sphinx_heigvd_theme">HEIG-VD Theme</a>.
</div>
            </div>
          </div>
      </page>
    </div>
    
    
  </body>
</html>