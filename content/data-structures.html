<!DOCTYPE html>
<html  lang="fr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <style type="text/css">
        p.rubric {
            font-weight: bold;
        }

        p.rubric:hover > a.headerlink {
            visibility: visible;
        }
    </style>
    
      <title>21 Structures de données</title>
    
      <link rel="stylesheet" href="../_static/pygments.css">
      <link rel="stylesheet" href="../_static/theme.css">
      
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>

      <!-- sphinx script_files -->
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="../_static/translations.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>

      
      <script src="../_static/theme-vendors.js"></script>
      <script src="../_static/theme.js" defer></script>
    
    <link rel="icon" href="../_static/favicon.ico" type="image/x-icon" />
  <link rel="index" title="Index" href="../genindex.html" />
  <link rel="search" title="Recherche" href="../search.html" />
  <link rel="next" title="22 Avancé" href="advanced-topics.html" />
  <link rel="prev" title="20 Qualité et Testabilité" href="testing.html" /> 
  </head>

  <body>
    <div id="app" class="theme-container" :class="pageClasses"><navbar @toggle-sidebar="toggleSidebar">
  <router-link to="../index.html" class="home-link">
    
      <span class="site-name">Le C pour l&#39;ingénieur</span>
    
  </router-link>

  <div class="links">
    <navlinks class="can-hide">

  
    <div class="nav-item">
      <a href="../index.html#le-c-pour-l-ingenieur"
         class="nav-link  router-link-active">
         Table des matières
      </a>
    </div>
  
    <div class="nav-item">
      <a href="../index.html#le-c-pour-l-ingenieur"
         class="nav-link ">
         Annexes
      </a>
    </div>
  
    <div class="nav-item">
      <a href="../index.html#le-c-pour-l-ingenieur"
         class="nav-link ">
         Références
      </a>
    </div>
  



    </navlinks>
  </div>
</navbar>

      
      <div class="sidebar-mask" @click="toggleSidebar(false)">
      </div>
        <sidebar @toggle-sidebar="toggleSidebar">
          
          <navlinks>
            

  
    <div class="nav-item">
      <a href="../index.html#le-c-pour-l-ingenieur"
         class="nav-link  router-link-active">
         Table des matières
      </a>
    </div>
  
    <div class="nav-item">
      <a href="../index.html#le-c-pour-l-ingenieur"
         class="nav-link ">
         Annexes
      </a>
    </div>
  
    <div class="nav-item">
      <a href="../index.html#le-c-pour-l-ingenieur"
         class="nav-link ">
         Références
      </a>
    </div>
  



            
          </navlinks><div id="searchbox" class="searchbox" role="search">
  <div class="caption"><span class="caption-text">Recherche rapide</span>
    <div class="searchformwrapper">
      <form class="search" action="../search.html" method="get">
        <input type="text" name="q" />
        <input type="submit" value="Recherche" />
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div><div class="sidebar-links" role="navigation" aria-label="main navigation">
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="../index.html#le-c-pour-l-ingenieur">Table des matières</a></span>
      </p>
      <ul class="current">
        
          <li class="toctree-l1 "><a href="introduction.html" class="reference internal ">Introduction</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="programming.html" class="reference internal ">La programmation</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="foundations.html" class="reference internal ">Généralités du langage</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="numeration.html" class="reference internal ">Numération</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="operators.html" class="reference internal ">Opérateurs</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="datatype.html" class="reference internal ">Types de données</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="control-structures.html" class="reference internal ">Structures de contrôle</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="processus.html" class="reference internal ">Programmes et Processus</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="stdio.html" class="reference internal ">Entrées Sorties</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="functions.html" class="reference internal ">Fonctions</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="composite-datatypes.html" class="reference internal ">Types composites</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="files.html" class="reference internal ">Les  fichiers</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="memory-management.html" class="reference internal ">Gestion de la mémoire</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="pointers.html" class="reference internal ">Pointeurs</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="standard-library.html" class="reference internal ">Bibliothèques</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="preprocessor.html" class="reference internal ">Préprocesseur</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="algorithms.html" class="reference internal ">Algorithmes et conception</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="translation-units.html" class="reference internal ">Compilation séparée</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="scopes.html" class="reference internal ">Portée et visibilité</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="testing.html" class="reference internal ">Qualité et Testabilité</a>

            
          </li>

        
          <li class="toctree-l1 current"><a href="#" class="reference internal current">Structures de données</a>

            
              <ul>
                
                  <li class="toctree-l2"><a href="#types-de-donnees-abstraits" class="reference internal">Types de données abstraits</a></li>
                
                  <li class="toctree-l2"><a href="#tableau-dynamique" class="reference internal">Tableau dynamique</a></li>
                
                  <li class="toctree-l2"><a href="#buffer-circulaire" class="reference internal">Buffer circulaire</a></li>
                
                  <li class="toctree-l2"><a href="#listes-chainees" class="reference internal">Listes chaînées</a></li>
                
                  <li class="toctree-l2"><a href="#liste-doublement-chainee" class="reference internal">Liste doublement chaînée</a></li>
                
                  <li class="toctree-l2"><a href="#liste-chainee-deroulee-unrolled-linked-list" class="reference internal">Liste chaînée déroulée (Unrolled linked list)</a></li>
                
                  <li class="toctree-l2"><a href="#arbre-binaire-de-recherche" class="reference internal">Arbre binaire de recherche</a></li>
                
                  <li class="toctree-l2"><a href="#heap" class="reference internal">Heap</a></li>
                
                  <li class="toctree-l2"><a href="#queue-prioritaire" class="reference internal">Queue prioritaire</a></li>
                
                  <li class="toctree-l2"><a href="#tableau-de-hachage" class="reference internal">Tableau de Hachage</a></li>
                
                  <li class="toctree-l2"><a href="#piles-ou-lifo-last-in-first-out" class="reference internal">Piles ou LIFO (Last In First Out)</a></li>
                
                  <li class="toctree-l2"><a href="#queues-ou-fifo-first-in-first-out" class="reference internal">Queues ou FIFO (First In First Out)</a></li>
                
                  <li class="toctree-l2"><a href="#performances" class="reference internal">Performances</a></li>
                
              </ul>
            
          </li>

        
          <li class="toctree-l1 "><a href="advanced-topics.html" class="reference internal ">Avancé</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="traps.html" class="reference internal ">Pièges</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="philosophy.html" class="reference internal ">Philosophie</a>

            
          </li>

        
      </ul>
    </div>
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="../index.html#le-c-pour-l-ingenieur">Annexes</a></span>
      </p>
      <ul class="">
        
          <li class="toctree-l1 "><a href="../appendix/vscode.html" class="reference internal ">Visual Studio Code</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="../appendix/grammar.html" class="reference internal ">Grammaire C</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="../appendix/bash.html" class="reference internal ">Ligne de commande</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="../appendix/development.html" class="reference internal ">Environnement de développement</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="../appendix/unit.html" class="reference internal ">Fiches d'unités de cours</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="../appendix/laboratories.html" class="reference internal ">Laboratoires</a>

            
          </li>

        
      </ul>
    </div>
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="../index.html#le-c-pour-l-ingenieur">Références</a></span>
      </p>
      <ul class="">
        
          <li class="toctree-l1 "><a href="../backmatter/exercises.html" class="reference internal ">Solution des exercices</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="../backmatter/bibliography.html" class="reference internal ">Bibliographie</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="../backmatter/glossary.html" class="reference internal ">Glossaire</a>

            
          </li>

        
      </ul>
    </div>
  
</div>
        </sidebar>

      <page>
          <div class="body-header" role="navigation" aria-label="navigation">
  
  <ul class="breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
    
    <li><span class="section-number">21  </span>Structures de données</li>
  </ul>
  

  <ul class="page-nav">
  <li class="prev">
    <a href="testing.html"
       title="Chapitre précédent">← <span class="section-number">20  </span>Qualité et Testabilité</a>
  </li>
  <li class="next">
    <a href="advanced-topics.html"
       title="Chapitre suivant"><span class="section-number">22  </span>Avancé →</a>
  </li>
</ul>
  
</div>
<hr>
          <div class="content" role="main">
            
  <div class="section" id="structures-de-donnees">
<h1><span class="section-number">21  </span>Structures de données<a class="headerlink" href="#structures-de-donnees" title="Lien permanent vers ce titre">¶</a></h1>
<div class="section" id="types-de-donnees-abstraits">
<h2><span class="section-number">21.1  </span>Types de données abstraits<a class="headerlink" href="#types-de-donnees-abstraits" title="Lien permanent vers ce titre">¶</a></h2>
<p>Un <a class="reference external" href="https://fr.wikipedia.org/wiki/Type_abstrait">type de donnée abstrait</a> (<strong>ADT</strong> pour Abstract Data Type) cache généralement une structure dont le contenu n'est pas connu de l'utilisateur final. Ceci est rendu possible par le standard (C99 §6.2.5) par l'usage de types incomplets.</p>
<p>Pour mémoire, un type incomplet décrit un objet dont on ne connaît pas sa taille en mémoire.</p>
<p>L'exemple suivant déclare un nouveau type structure qui n'est alors pas (encore) connu dans le fichier courant :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">Unknown</span><span class="w"> </span><span class="o">*</span><span class="n">Known</span><span class="p">;</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Known</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span><span class="w"> </span><span class="c1">// Autorisé, le type est incomplet</span>

<span class="w">    </span><span class="n">foo</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// Impossible car la taille de foo est inconnue.</span>
<span class="w">    </span><span class="n">foo</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span><span class="w"> </span><span class="c1">// Impossible car le type est incomplet.</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>De façon générale, les types abstraits sont utilisés dans l'écriture de bibliothèques logicielles lorsqu'il est important que l'utilisateur final ne puisse pas compromettre le contenu du type et en forçant cet utilisateur à ne passer que par des fonctions d'accès.</p>
<p>Prenons le cas du fichier <cite>foobar.c</cite> lequel décrit une structure <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Foo</span></code> et un type <code class="docutils literal notranslate"><span class="pre">Foo</span></code>. Notez que le type peut être déclaré avant la structure. <code class="docutils literal notranslate"><span class="pre">Foo</span></code> restera abstrait jusqu'à la déclaration complète de la structure <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Foo</span></code> permettant de connaître sa taille. Ce fichier contient également trois fonctions :</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">init</span></code> permet d'initialiser la structure ;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">get</span></code> permet de récupérer la valeur contenue dans <code class="docutils literal notranslate"><span class="pre">Foo</span></code> ;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">set</span></code> permet d'assigner une valeur à <code class="docutils literal notranslate"><span class="pre">Foo</span></code>.</p></li>
</ul>
<p>En plus, il existe un compteur d'accès <code class="docutils literal notranslate"><span class="pre">count</span></code> qui s'incrémente lorsque l'on assigne une valeur et se décrémente lorsque l'on récupère une valeur.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="n">Foo</span><span class="p">;</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="n">Foo</span><span class="o">**</span><span class="w"> </span><span class="n">foo</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="o">*</span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Foo</span><span class="p">));</span><span class="w"> </span><span class="c1">// Allocation dynamique</span>
<span class="w">    </span><span class="p">(</span><span class="o">*</span><span class="n">foo</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">foo</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">get</span><span class="p">(</span><span class="n">Foo</span><span class="o">*</span><span class="w"> </span><span class="n">foo</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">foo</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">--</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">foo</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">set</span><span class="p">(</span><span class="n">Foo</span><span class="o">*</span><span class="w"> </span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">foo</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">foo</span><span class="o">-&gt;</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Évidemment, on ne souhaite pas qu'un petit malin compromette ce compteur en écrivant maladroitement :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">foo</span><span class="o">-&gt;</span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span><span class="w"> </span><span class="c1">// Hacked this !</span>
</pre></div>
</div>
<p>Pour s'en protéger, on a recours à la compilation séparée (voir chapitre <a class="reference internal" href="translation-units.html#translationunits"><span class="std std-ref">Compilation séparée</span></a>) dans laquelle le programme est découpé en plusieurs fichiers. Le fichier <code class="docutils literal notranslate"><span class="pre">foobar.h</span></code> contiendra tout ce qui doit être connu du programme principal, à savoir les prototypes des fonctions, et le type abstrait :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma once</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="n">Foo</span><span class="p">;</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="n">Foo</span><span class="o">**</span><span class="w"> </span><span class="n">foo</span><span class="p">);</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">get</span><span class="p">(</span><span class="n">Foo</span><span class="o">*</span><span class="w"> </span><span class="n">foo</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">set</span><span class="p">(</span><span class="n">Foo</span><span class="o">*</span><span class="w"> </span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Ce fichier sera inclus dans le programme principal <code class="docutils literal notranslate"><span class="pre">main.c</span></code> :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;foobar.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Foo</span><span class="w"> </span><span class="o">*</span><span class="n">foo</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">foo</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">set</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="mi">23</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">get</span><span class="p">(</span><span class="n">foo</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>En résumé, un type abstrait impose l'utilisation de fonctions intermédiaires pour modifier le type. Dans la grande majorité des cas, ces types représentent des structures qui contiennent des informations internes qui ne sont pas destinées à être modifiées par l'utilisateur final.</p>
</div>
<div class="section" id="tableau-dynamique">
<h2><span class="section-number">21.2  </span>Tableau dynamique<a class="headerlink" href="#tableau-dynamique" title="Lien permanent vers ce titre">¶</a></h2>
<p>Un tableau dynamique aussi appelé <em>vecteur</em> est, comme son nom l'indique, alloué dynamiquement dans le <em>heap</em> en fonction des besoins. Vous vous rappelez que le <em>heap</em> grossit à chaque appel de <code class="docutils literal notranslate"><span class="pre">malloc</span></code> et diminue à chaque appel de <code class="docutils literal notranslate"><span class="pre">free</span></code>.</p>
<p>Un tableau dynamique est souvent spécifié par un facteur de croissance (rien à voir avec les hormones). Lorsque le tableau est plein et que l'on souhaite rajouter un nouvel élément, le tableau est réalloué dans un autre espace mémoire plus grand avec la fonction <code class="docutils literal notranslate"><span class="pre">realloc</span></code>. Cette dernière n'est rien d'autre qu'un <code class="docutils literal notranslate"><span class="pre">malloc</span></code> suivi d'un <code class="docutils literal notranslate"><span class="pre">memcopy</span></code> suivi d'un <code class="docutils literal notranslate"><span class="pre">free</span></code>. Un nouvel espace mémoire est réservé, les données sont copiées du premier espace vers le nouveau, et enfin le premier espace est libéré. Voici un exemple :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Alloue un espace de trois chars</span>
<span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Rempli le buffer</span>
<span class="n">buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;h&#39;</span><span class="p">;</span><span class="w"></span>
<span class="n">buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;e&#39;</span><span class="p">;</span><span class="w"></span>
<span class="n">buffer</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;l&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Le buffer est plein...</span>

<span class="c1">// Augmente dynamiquement la taille du buffer à 5 chars</span>
<span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">realloc</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span><span class="w"></span>
<span class="n">assert</span><span class="p">(</span><span class="n">tmp</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span><span class="w"></span>
<span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Continue de remplir le buffer</span>
<span class="n">buffer</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;l&#39;</span><span class="p">;</span><span class="w"></span>
<span class="n">buffer</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;o&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Le buffer est à nouveau plein...</span>

<span class="c1">// Libère l&#39;espace mémoire utilisé</span>
<span class="n">free</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>La taille du nouvel espace mémoire est plus grande d'un facteur donné que l'ancien espace. Selon les langages de programmation et les compilateurs, ces facteurs sont compris entre 3/2 et 2. C'est-à-dire que la taille du tableau prendra les tailles de 1, 2, 4, 8, 16, 32, etc.</p>
<p>Lorsque le nombre d'éléments du tableau devient inférieur du facteur de croissance à la taille effective du tableau, il est possible de faire l'opération inverse, c'est-à-dire réduire la taille allouée. En pratique cette opération est rarement implémentée, car peu efficace (c.f. <a class="reference external" href="https://stackoverflow.com/a/60827815/2612235">cette</a> réponse sur stackoverflow).</p>
<div class="section" id="anatomie">
<h3><span class="section-number">21.2.1  </span>Anatomie<a class="headerlink" href="#anatomie" title="Lien permanent vers ce titre">¶</a></h3>
<p id="index-0">Un tableau dynamique est représenté en mémoire comme un contenu séquentiel qui possède un début et une fin. On appelle son début la <strong>tête</strong> ou <em>head</em> et la fin du tableau sa <strong>queue</strong> ou <em>tail</em>. Selon que l'on souhaite ajouter des éléments au début ou à la fin du tableau la complexité n'est pas la même.</p>
<p>Nous définirons par la suite le vocabulaire suivant:</p>
<table class="docutils align-default" id="id1">
<caption><span class="caption-number">Tableau 21.1 </span><span class="caption-text">Vocabulaire des actions sur un tableau dynamique</span><a class="headerlink" href="#id1" title="Lien permanent vers ce tableau">¶</a></caption>
<colgroup>
<col style="width: 75%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Action</p></th>
<th class="head"><p>Terme technique</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Ajout d'un élément à la tête du tableau</p></td>
<td><p><cite>unshift</cite></p></td>
</tr>
<tr class="row-odd"><td><p>Ajout d'un élément à la queue du tableau</p></td>
<td><p><cite>push</cite></p></td>
</tr>
<tr class="row-even"><td><p>Suppression d'un élément à la tête du tableau</p></td>
<td><p><cite>shift</cite></p></td>
</tr>
<tr class="row-odd"><td><p>Suppression d'un élément à la queue du tableau</p></td>
<td><p><cite>pop</cite></p></td>
</tr>
</tbody>
</table>
<p>Nous comprenons rapidement qu'il est plus compliqué d'ajouter ou de supprimer un élément depuis la tête du tableau, car il est nécessaire ensuite de déplacer chaque élément (l'élément 0 devient l'élément 1, l'élément 1 devient l'élément 2...).</p>
<p>Un tableau dynamique peut être représenté par la figure suivante :</p>
<div class="figure align-default" id="id2">
<img alt="../_images/dyn-array.svg" src="../_images/dyn-array.svg" /><p class="caption"><span class="caption-number">Fig. 21.1 </span><span class="caption-text">Tableau dynamique</span><a class="headerlink" href="#id2" title="Lien permanent vers cette image">¶</a></p>
</div>
<p>Un espace mémoire est réservé dynamiquement sur le tas. Comme <code class="docutils literal notranslate"><span class="pre">malloc</span></code> ne retourne pas la taille de l'espace mémoire alloué, mais juste un pointeur sur cet espace, il est nécessaire de conserver dans une variable la capacité du tableau. Notons qu'un tableau de 10 <code class="docutils literal notranslate"><span class="pre">int32_t</span></code> représentera un espace mémoire de 4x10 bytes, soit 40 bytes. La mémoire ainsi réservée par <code class="docutils literal notranslate"><span class="pre">malloc</span></code> n'est généralement pas vide, mais elle contient des valeurs, vestige d'une ancienne allocation mémoire d'un autre programme depuis que l'ordinateur a été allumé. Pour connaître le nombre d'éléments effectifs du tableau, il faut également le mémoriser. Enfin, le pointeur sur l'espace mémoire est aussi mémorisé.</p>
<p>Les composants de cette structure de donnée sont donc :</p>
<ul class="simple">
<li><p>Un entier non signé <code class="docutils literal notranslate"><span class="pre">size_t</span></code> représentant la capacité totale du tableau dynamique à un instant T.</p></li>
<li><p>Un entier non signé <code class="docutils literal notranslate"><span class="pre">size_t</span></code> représentant le nombre d'éléments effectivement dans le tableau.</p></li>
<li><p>Un pointeur sur un entier <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*</span></code> contenant l'adresse mémoire de l'espace alloué par <code class="docutils literal notranslate"><span class="pre">malloc</span></code>.</p></li>
<li><p>Un espace mémoire alloué par <code class="docutils literal notranslate"><span class="pre">malloc</span></code> et contenant des données.</p></li>
</ul>
<p id="index-1">L'opération <code class="docutils literal notranslate"><span class="pre">pop</span></code> retire l'élément de la fin du tableau. Le nombre d'éléments est donc ajusté en conséquence.</p>
<div class="figure align-default" id="id3">
<a class="reference internal image-reference" href="../_images/dyn-array-pop.svg"><img alt="../_images/dyn-array-pop.svg" height="172" src="../_images/dyn-array-pop.svg" width="480" /></a>
<p class="caption"><span class="caption-number">Fig. 21.2 </span><span class="caption-text">Suppression d'un élément dans un tableau dynamique</span><a class="headerlink" href="#id3" title="Lien permanent vers cette image">¶</a></p>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">elements</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="o">--</span><span class="n">elements</span><span class="p">];</span><span class="w"></span>
</pre></div>
</div>
<p id="index-2">L'opération <code class="docutils literal notranslate"><span class="pre">push</span></code> ajoute un élément à la fin du tableau.</p>
<div class="figure align-default" id="id4">
<a class="reference internal image-reference" href="../_images/dyn-array-push.svg"><img alt="../_images/dyn-array-push.svg" height="183" src="../_images/dyn-array-push.svg" width="480" /></a>
<p class="caption"><span class="caption-number">Fig. 21.3 </span><span class="caption-text">Ajout d'un élément dans un tableau dynamique</span><a class="headerlink" href="#id4" title="Lien permanent vers cette image">¶</a></p>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">elements</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">capacity</span><span class="p">)</span><span class="w"> </span><span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span><span class="w"></span>
<span class="n">data</span><span class="p">[</span><span class="n">elements</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>L'opération <code class="docutils literal notranslate"><span class="pre">shift</span></code> retire un élément depuis le début. L'opération à une complexité de O(n) puisqu'à chaque opération il est nécessaire de déplacer chaque élément qu'il contient.</p>
<div class="figure align-default" id="id5">
<a class="reference internal image-reference" href="../_images/dyn-array-shift.svg"><img alt="../_images/dyn-array-shift.svg" height="177" src="../_images/dyn-array-shift.svg" width="480" /></a>
<p class="caption"><span class="caption-number">Fig. 21.4 </span><span class="caption-text">Suppression du premier élément dans un tableau dynamique</span><a class="headerlink" href="#id5" title="Lien permanent vers cette image">¶</a></p>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">elements</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">capacity</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
</pre></div>
</div>
<p>Une optimisation peut être faite en déplaçant le pointeur de donnée de 1 permettant de réduite la complexité à O(1) :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">elements</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">capacity</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="n">data</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="n">capacity</span><span class="o">--</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p id="index-3">Enfin, l'opération <code class="docutils literal notranslate"><span class="pre">unshift</span></code> ajoute un élément depuis le début du tableau :</p>
<div class="figure align-default" id="id6">
<a class="reference internal image-reference" href="../_images/dyn-array-unshift.svg"><img alt="../_images/dyn-array-unshift.svg" height="179" src="../_images/dyn-array-unshift.svg" width="480" /></a>
<p class="caption"><span class="caption-number">Fig. 21.5 </span><span class="caption-text">Ajout d'un élément en début d'un tableau dynamique</span><a class="headerlink" href="#id6" title="Lien permanent vers cette image">¶</a></p>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">elements</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">--</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Dans le cas ou le nombre d'éléments atteint la capacité maximum du tableau, il est nécessaire de réallouer l'espace mémoire avec <code class="docutils literal notranslate"><span class="pre">realloc</span></code>. Généralement on se contente de doubler l'espace alloué.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">elements</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">capacity</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">realloc</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">capacity</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="buffer-circulaire">
<h2><span class="section-number">21.3  </span>Buffer circulaire<a class="headerlink" href="#buffer-circulaire" title="Lien permanent vers ce titre">¶</a></h2>
<p>Un <span class="target" id="index-4"></span>tampon circulaire aussi appelé <span class="target" id="index-5"></span>buffer circulaire ou <span class="target" id="index-6"></span>ring buffer en anglais est généralement d'une taille fixe et possède deux pointeurs. L'un pointant sur le dernier élément (<em>tail</em>) et l'un sur le premier élément (<em>head</em>).</p>
<p>Lorsqu'un élément est supprimé du buffer, le pointeur de fin est incrémenté. Lorsqu'un élément est ajouté, le pointeur de début est incrémenté.</p>
<p>Pour permettre la circulation, les indices sont calculés modulo la taille du buffer.</p>
<p>Il est possible de représenter schématiquement ce buffer comme un cercle et ses deux pointeurs :</p>
<div class="figure align-default" id="id7">
<a class="reference internal image-reference" href="../_images/ring.svg"><img alt="../_images/ring.svg" height="298" src="../_images/ring.svg" width="571" /></a>
<p class="caption"><span class="caption-number">Fig. 21.6 </span><span class="caption-text">Exemple d'un tampon circulaire</span><a class="headerlink" href="#id7" title="Lien permanent vers cette image">¶</a></p>
</div>
<p>Le nombre d'éléments dans le buffer est la différence entre le pointeur de tête et le pointeur de queue, modulo la taille du buffer. Néanmoins, l'opérateur <code class="docutils literal notranslate"><span class="pre">%</span></code> en C ne fonctionne que sur des nombres positifs et ne retourne pas le résidu positif le plus petit. En sommes, <code class="docutils literal notranslate"><span class="pre">-2</span> <span class="pre">%</span> <span class="pre">5</span></code> devrait donner <code class="docutils literal notranslate"><span class="pre">3</span></code>, ce qui est le cas en Python, mais en C, en C++ ou en PHP la valeur retournée est <code class="docutils literal notranslate"><span class="pre">-2</span></code>. Le modulo vrai, mathématiquement correct peut être calculé ainsi :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="p">((</span><span class="n">A</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">M</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">M</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">M</span><span class="w"></span>
</pre></div>
</div>
<p>Les indices sont bouclés sur la taille du buffer, l'élément suivant est donc défini par :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">SIZE</span><span class="w"></span>
</pre></div>
</div>
<p>Voici une implémentation possible du buffer circulaire :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define SIZE 16</span>
<span class="cp">#define MOD(A, M) (((A % M) + M) % M)</span>
<span class="cp">#define NEXT(A) (((A) + 1) % SIZE)</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">Ring</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">buffer</span><span class="p">[</span><span class="n">SIZE</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">head</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tail</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">Ring</span><span class="p">;</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="n">Ring</span><span class="w"> </span><span class="o">*</span><span class="n">ring</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">count</span><span class="p">(</span><span class="n">Ring</span><span class="w"> </span><span class="o">*</span><span class="n">ring</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">MOD</span><span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">head</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">bool</span><span class="w"> </span><span class="nf">is_full</span><span class="p">(</span><span class="n">Ring</span><span class="w"> </span><span class="o">*</span><span class="n">ring</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">count</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">bool</span><span class="w"> </span><span class="nf">is_empty</span><span class="p">(</span><span class="n">Ring</span><span class="w"> </span><span class="o">*</span><span class="n">ring</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">tail</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="nf">enqueue</span><span class="p">(</span><span class="n">Ring</span><span class="w"> </span><span class="o">*</span><span class="n">ring</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_full</span><span class="p">(</span><span class="n">ring</span><span class="p">))</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">[</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">el</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">[</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NEXT</span><span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">el</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="nf">dequeue</span><span class="p">(</span><span class="n">Ring</span><span class="w"> </span><span class="o">*</span><span class="n">ring</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_empty</span><span class="p">(</span><span class="n">ring</span><span class="p">))</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">el</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">[</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NEXT</span><span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">el</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="listes-chainees">
<h2><span class="section-number">21.4  </span>Listes chaînées<a class="headerlink" href="#listes-chainees" title="Lien permanent vers ce titre">¶</a></h2>
<p id="index-7">On s'aperçoit vite avec les tableaux que certaines opérations sont plus coûteuses que d'autres. Ajouter ou supprimer un élément à la fin du tableau coûte <span class="math notranslate nohighlight">\(O(1)\)</span> amorti, mais ajouter ou supprimer un élément à l'intérieur du tableau coûte <span class="math notranslate nohighlight">\(O(n)\)</span> du fait qu'il est nécessaire de déplacer tous les éléments qui suivent l'élément concerné.</p>
<p>Une possible solution à ce problème serait de pouvoir s'affranchir du lien entre les éléments et leurs positions en mémoire relative les uns aux autres.</p>
<p>Pour illustrer cette idée, imaginons un tableau statique dans lequel chaque élément est décrit par la structure suivante :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">Element</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">index_next_element</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="nc">Element</span><span class="w"> </span><span class="n">elements</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span><span class="w"></span>
</pre></div>
</div>
<p>Considérons les dix premiers éléments de la séquence de nombre <a class="reference external" href="https://oeis.org/A130826">A130826</a> dans un tableau statique. Ensuite, répartissons ces valeurs aléatoirement dans notre tableau <cite>elements</cite> déclaré plus haut entre les indices 0 et 19.</p>
<div class="figure align-default" id="id8">
<img alt="../_images/static-linked-list.svg" src="../_images/static-linked-list.svg" /><p class="caption"><span class="caption-number">Fig. 21.7 </span><span class="caption-text">Construction d'une liste chainée à l'aide d'un tableau</span><a class="headerlink" href="#id8" title="Lien permanent vers cette image">¶</a></p>
</div>
<p>On observe sur la figure ci-dessus que les éléments n'ont plus besoin de se suivre en mémoire, car il est possible facilement de chercher l'élément suivant de la liste avec cette relation :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">Element</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">elements</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Element</span><span class="w"> </span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">elements</span><span class="p">[</span><span class="n">current</span><span class="p">.</span><span class="n">index_next_element</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>De même, insérer une nouvelle valeur <cite>13</cite> après la valeur <cite>42</cite> est très facile:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Recherche de l&#39;élément contenant la valeur 42</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Element</span><span class="w"> </span><span class="n">el</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">elements</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">el</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">42</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">el</span><span class="p">.</span><span class="n">index_next_element</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">el</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">elements</span><span class="p">[</span><span class="n">el</span><span class="p">.</span><span class="n">index_next_element</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">el</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">42</span><span class="p">)</span><span class="w"> </span><span class="n">abort</span><span class="p">();</span><span class="w"></span>

<span class="c1">// Recherche d&#39;un élément libre</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">elements</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">elements</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="p">;</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">length</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">elements</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">index_next_element</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="n">assert</span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">elements</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">index_next_element</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Création d&#39;un nouvel élément</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Element</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Element</span><span class="p">){</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">13</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">index_next_element</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="c1">// Insertion de l&#39;élément quelque part dans le tableau</span>
<span class="n">el</span><span class="p">.</span><span class="n">index_next_element</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">k</span><span class="p">;</span><span class="w"></span>
<span class="n">elements</span><span class="p">[</span><span class="n">el</span><span class="p">.</span><span class="n">index_next_element</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Cette solution d'utiliser un lien vers l'élément suivant et s'appelle liste chaînée. Chaque élément dispose d'un lien vers l'élément suivant situé quelque part en mémoire. Les opérations d'insertion et de suppression au milieu de la chaîne sont maintenant effectuées en <span class="math notranslate nohighlight">\(O(1)\)</span> contre <span class="math notranslate nohighlight">\(O(n)\)</span> pour un tableau standard. En revanche l'espace nécessaire pour stocker ce tableau est doublé puisqu'il faut associer à chaque valeur le lien vers l'élément suivant.</p>
<p>D'autre part, la solution proposée n'est pas optimale :</p>
<ul class="simple">
<li><p>L'élément 0 est un cas particulier qu'il faut traiter différemment. Le premier élément de la liste doit toujours être positionné à l'indice 0 du tableau. Insérer un nouvel élément en début de tableau demande de déplacer cet élément ailleurs en mémoire.</p></li>
<li><p>Rechercher un élément libre prend du temps.</p></li>
<li><p>Supprimer un élément dans le tableau laisse une place mémoire vide. Il devient alors difficile de savoir où sont les emplacements mémoires disponibles.</p></li>
</ul>
<p>Une liste chaînée est une structure de données permettant de lier des éléments structurés entre eux. La liste est caractérisée par :</p>
<ul class="simple">
<li><p>un élément de tête (<em>head</em>),</p></li>
<li><p>un élément de queue (<em>tail</em>).</p></li>
</ul>
<p>Un élément est caractérisé par :</p>
<ul class="simple">
<li><p>un contenu (<em>payload</em>),</p></li>
<li><p>une référence vers l'élément suivant et/ou précédent dans la liste.</p></li>
</ul>
<p>Les listes chaînées réduisent la complexité liée à la manipulation d'éléments dans une liste. L'empreinte mémoire d'une liste chaînée est plus grande qu'avec un tableau, car à chaque élément de donnée est associé un pointeur vers l'élément suivant ou précédent.</p>
<p>Ce surcoût est souvent part du compromis entre la complexité d'exécution du code et la mémoire utilisée par ce programme.</p>
<table class="docutils align-default" id="id9">
<caption><span class="caption-number">Tableau 21.2 </span><span class="caption-text">Coût des opérations dans des structures de données récursives</span><a class="headerlink" href="#id9" title="Lien permanent vers ce tableau">¶</a></caption>
<colgroup>
<col style="width: 27%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 23%" />
<col style="width: 17%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head" rowspan="3"><p>Structure de donnée</p></th>
<th class="head"><p>Pire cas</p></th>
<th class="head"></th>
<th class="head" colspan="2"><div class="line-block">
<div class="line"><br /></div>
</div>
</th>
</tr>
<tr class="row-even"><th class="head"><p>Insertion</p></th>
<th class="head"><p>Suppression</p></th>
<th class="head" colspan="2"><p>Recherche     |</p></th>
</tr>
<tr class="row-odd"><th class="head"></th>
<th class="head"></th>
<th class="head"><p>Trié</p></th>
<th class="head"><p>Pas trié</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Tableau, pile, queue</p></td>
<td><p><span class="math notranslate nohighlight">\(O(n)\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(O(n)\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(O(log(n))\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(O(n)\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>Liste chaînée simple</p></td>
<td><p><span class="math notranslate nohighlight">\(O(1)\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(O(1)\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(O(n)\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(O(n)\)</span></p></td>
</tr>
</tbody>
</table>
<div class="section" id="liste-simplement-chainee-linked-list">
<h3><span class="section-number">21.4.1  </span>Liste simplement chaînée (<em>linked-list</em>)<a class="headerlink" href="#liste-simplement-chainee-linked-list" title="Lien permanent vers ce titre">¶</a></h3>
<p id="index-8">La figure suivante illustre un set d'éléments liés entre eux à l'aide d'un pointeur rattaché à chaque élément. On peut s'imaginer que chaque élément peut se situer n'importe où en mémoire et
qu'il n'est alors pas indispensable que les éléments se suivent dans l'ordre.</p>
<p>Il est indispensable de bien identifier le dernier élément de la liste grâce à son pointeur associé
à la valeur <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<div class="figure align-default" id="id10">
<img alt="../_images/list.svg" src="../_images/list.svg" /><p class="caption"><span class="caption-number">Fig. 21.8 </span><span class="caption-text">Liste chaînée simple</span><a class="headerlink" href="#id10" title="Lien permanent vers cette image">¶</a></p>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>

<span class="k">struct</span><span class="w"> </span><span class="nc">Point</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">z</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="nc">Element</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Point</span><span class="w"> </span><span class="n">point</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Element</span><span class="o">*</span><span class="w"> </span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Element</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{.</span><span class="n">point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">},</span><span class="w"> </span><span class="p">.</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Element</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{.</span><span class="n">point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">},</span><span class="w"> </span><span class="p">.</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Element</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{.</span><span class="n">point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">},</span><span class="w"> </span><span class="p">.</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="n">a</span><span class="p">.</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">c</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Element</span><span class="o">*</span><span class="w"> </span><span class="n">walk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d. P(x, y, z) = %0.2f, %0.2f, %0.2f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">i</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">walk</span><span class="o">-&gt;</span><span class="n">point</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">walk</span><span class="o">-&gt;</span><span class="n">point</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">walk</span><span class="o">-&gt;</span><span class="n">point</span><span class="p">.</span><span class="n">z</span><span class="w"></span>
<span class="w">        </span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="n">walk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">walk</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="operations-sur-une-liste-chainee">
<h3><span class="section-number">21.4.2  </span>Opérations sur une liste chaînée<a class="headerlink" href="#operations-sur-une-liste-chainee" title="Lien permanent vers ce titre">¶</a></h3>
<ul class="simple">
<li><p>Création</p></li>
<li><p>Nombre d'éléments</p></li>
<li><p>Recherche</p></li>
<li><p>Insertion</p></li>
<li><p>Suppression</p></li>
<li><p>Concaténation</p></li>
<li><p>Destruction</p></li>
</ul>
<p>Lors de la création d'un élément, on utilise principalement le mécanisme
de l'allocation dynamique ce qui permet de récupérer l'adresse de
l'élément et de faciliter sa manipulation au travers de la liste.  Ne
pas oublier de libérer la mémoire allouée pour les éléments lors de leur
suppression…</p>
<div class="section" id="calcul-du-nombre-d-elements-dans-la-liste">
<h4><span class="section-number">21.4.2.1  </span>Calcul du nombre d'éléments dans la liste<a class="headerlink" href="#calcul-du-nombre-d-elements-dans-la-liste" title="Lien permanent vers ce titre">¶</a></h4>
<p>Pour évaluer le nombre d'éléments dans une liste, on effectue le
parcours de la liste à partir de la tête, et on passe d'élément en
élément grâce au champ <em>next</em> de la structure <code class="docutils literal notranslate"><span class="pre">Element</span></code>. On incrément
le nombre d'éléments jusqu'à ce que le pointeur <em>next</em> soit égal à <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Element</span><span class="w"> </span><span class="o">*</span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">head</span><span class="p">;</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">e</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">count</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Attention, cette technique ne fonctionne pas dans tous les cas, spécialement lorsqu'il y a des boucles dans la liste chaînée. Prenons l'exemple suivant :</p>
<div class="figure align-default" id="id11">
<a class="reference internal image-reference" href="../_images/loop.svg"><img alt="../_images/loop.svg" height="293" src="../_images/loop.svg" width="513" /></a>
<p class="caption"><span class="caption-number">Fig. 21.9 </span><span class="caption-text">Boucle dans une liste chaînée</span><a class="headerlink" href="#id11" title="Lien permanent vers cette image">¶</a></p>
</div>
<p>La liste se terminant par une boucle, il n'y aura jamais d'élément de fin et le nombre d'éléments
calculé sera infini. Or, cette liste a un nombre fixe d'éléments. Comment donc les compter ?</p>
<p>Il existe un algorithme nommé détection de cycle de Robert W. Floyd aussi appelé <em>algorithme du lièvre et de la tortue</em>. Il consiste à avoir deux pointeurs qui parcourent la liste chaînée. L'un avance deux fois plus vite que le second.</p>
<div class="figure align-default" id="id12">
<span id="index-9"></span><a class="reference internal image-reference" href="../_images/floyd.svg"><img alt="../_images/floyd.svg" height="515" src="../_images/floyd.svg" width="369" /></a>
<p class="caption"><span class="caption-number">Fig. 21.10 </span><span class="caption-text">Algorithme de détection de cycle de Robert W. Floyd</span><a class="headerlink" href="#id12" title="Lien permanent vers cette image">¶</a></p>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">size_t</span><span class="w"> </span><span class="nf">compute_length</span><span class="p">(</span><span class="n">Element</span><span class="o">*</span><span class="w"> </span><span class="n">head</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">Element</span><span class="o">*</span><span class="w"> </span><span class="n">slow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">Element</span><span class="o">*</span><span class="w"> </span><span class="n">fast</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">fast</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">slow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slow</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">fast</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="n">count</span><span class="o">++</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">slow</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">fast</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="c1">// Collision</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Case when no loops detected</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fast</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">count</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Move slow to head, keep fast at meeting point.</span>
<span class="w">    </span><span class="n">slow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">slow</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">fast</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">slow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slow</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">fast</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="n">count</span><span class="o">--</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">count</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Une bonne idée pour se simplifier la vie est simplement d'éviter la création de boucles.</p>
</div>
<div class="section" id="insertion">
<h4><span class="section-number">21.4.2.2  </span>Insertion<a class="headerlink" href="#insertion" title="Lien permanent vers ce titre">¶</a></h4>
<p>L'insertion d'un élément dans une liste chaînée peut-être implémentée de la façon suivante :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">Element</span><span class="o">*</span><span class="w"> </span><span class="nf">insert_after</span><span class="p">(</span><span class="n">Element</span><span class="o">*</span><span class="w"> </span><span class="n">e</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">payload</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Element</span><span class="o">*</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Element</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">memcpy</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">,</span><span class="w"> </span><span class="n">payload</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">new</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">e</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">e</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">new</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="suppression">
<h4><span class="section-number">21.4.2.3  </span>Suppression<a class="headerlink" href="#suppression" title="Lien permanent vers ce titre">¶</a></h4>
<p>La suppression implique d'accéder à l'élément parent, il n'est donc pas possible à partir d'un élément donné de le supprimer de la liste.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">delete_after</span><span class="p">(</span><span class="n">Element</span><span class="o">*</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">e</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">e</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">e</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="recherche">
<h4><span class="section-number">21.4.2.4  </span>Recherche<a class="headerlink" href="#recherche" title="Lien permanent vers ce titre">¶</a></h4>
<p>Rechercher dans une liste chaînée est une question qui peut-être complexe et il est nécessaire de ce poser un certain nombre de questions :</p>
<ul class="simple">
<li><p>Est-ce que la liste est triée?</p></li>
<li><p>Combien d'espace mémoire puis-je utiliser?</p></li>
</ul>
<p>On sait qu'une recherche idéale s'effectue en <span class="math notranslate nohighlight">\(O(log(n))\)</span>, mais que la solution triviale en <span class="math notranslate nohighlight">\(O(n)\)</span> est la suivante :</p>
</div>
</div>
</div>
<div class="section" id="liste-doublement-chainee">
<h2><span class="section-number">21.5  </span>Liste doublement chaînée<a class="headerlink" href="#liste-doublement-chainee" title="Lien permanent vers ce titre">¶</a></h2>
<div class="section" id="liste-chainee-xor">
<h3><span class="section-number">21.5.1  </span>Liste chaînée XOR<a class="headerlink" href="#liste-chainee-xor" title="Lien permanent vers ce titre">¶</a></h3>
<p>L'inconvénient d'une liste doublement chaînée est le surcoût nécessaire au stockage d'un élément. Chaque élément contient en effet deux pointeurs sur l'élément précédent (<em>prev</em>) et suivant (<em>next</em>).</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>...  A       B         C         D         E  ...
        –&gt;  next –&gt;  next  –&gt;  next  –&gt;
        &lt;–  prev &lt;–  prev  &lt;–  prev  &lt;–
</pre></div>
</div>
<p>Cette liste chaînée particulière compresse les deux pointeurs en un seul en utilisant l'opération XOR (dénotée ⊕).</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>...  A        B         C         D         E  ...
        &lt;–&gt;  A⊕C  &lt;-&gt;  B⊕D  &lt;-&gt;  C⊕E  &lt;-&gt;
</pre></div>
</div>
<p>Lorsque la liste est traversée de gauche à droite, il est possible de facilement reconstruire le pointeur de l'élément suivant à partir de l'adresse de l'élément précédent.</p>
<p>Les inconvénients de cette structure sont :</p>
<ul class="simple">
<li><p>Difficultés de débogage</p></li>
<li><p>Complexité de mise en œuvre</p></li>
</ul>
<p>L'avantage principal étant le gain de place en mémoire.</p>
</div>
</div>
<div class="section" id="liste-chainee-deroulee-unrolled-linked-list">
<h2><span class="section-number">21.6  </span>Liste chaînée déroulée (Unrolled linked list)<a class="headerlink" href="#liste-chainee-deroulee-unrolled-linked-list" title="Lien permanent vers ce titre">¶</a></h2>
<p>Une liste chaînée déroulée rassemble les avantages d'un tableau et d'une liste chaînée. Elle permet d'accroître les performances en réduisant l'overhead de réservation mémoire avec <cite>malloc</cite>.</p>
<div class="figure align-default" id="id13">
<a class="reference internal image-reference" href="../_images/unrolled-linked-list.svg"><img alt="../_images/unrolled-linked-list.svg" height="190" src="../_images/unrolled-linked-list.svg" width="565" /></a>
<p class="caption"><span class="caption-number">Fig. 21.11 </span><span class="caption-text">Liste chaînée déroulée</span><a class="headerlink" href="#id13" title="Lien permanent vers cette image">¶</a></p>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">Node</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Node</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="p">;</span><span class="w">  </span><span class="c1">// Nombre d&#39;éléments</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">elements</span><span class="p">[];</span><span class="w"> </span><span class="c1">// Membre flexible contenant les éléments</span>
<span class="p">}</span><span class="w"> </span><span class="n">Node</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="arbre-binaire-de-recherche">
<h2><span class="section-number">21.7  </span>Arbre binaire de recherche<a class="headerlink" href="#arbre-binaire-de-recherche" title="Lien permanent vers ce titre">¶</a></h2>
<p>L'objectif de cette section n'est pas d'entrer dans les détails des <a class="reference external" href="https://fr.wikipedia.org/wiki/Arbre_binaire_de_recherche">arbres binaires</a> dont la théorie requiert un ouvrage dédié, mais de vous sensibiliser à l'existence de ces structures de données qui sont à la base de beaucoup de langage de haut niveau comme C++, Python ou C#.</p>
<p>L'arbre binaire, n'est rien d'autre qu'une liste chaînée comportant deux enfants un <code class="docutils literal notranslate"><span class="pre">left</span></code> et un <code class="docutils literal notranslate"><span class="pre">right</span></code>:</p>
<div class="figure align-default" id="id14">
<a class="reference internal image-reference" href="../_images/binary-tree.svg"><img alt="../_images/binary-tree.svg" height="272" src="../_images/binary-tree.svg" width="294" /></a>
<p class="caption"><span class="caption-number">Fig. 21.12 </span><span class="caption-text">Arbre binaire équilibré</span><a class="headerlink" href="#id14" title="Lien permanent vers cette image">¶</a></p>
</div>
<p>Lorsqu'il est équilibré, un arbre binaire comporte autant d'éléments à gauche qu'à droite et lorsqu'il est correctement rempli, la valeur d'un élément est toujours :</p>
<ul class="simple">
<li><p>La valeur de l'enfant de gauche est inférieure à celle de son parent</p></li>
<li><p>La valeur de l'enfant de droite est supérieure à celle de son parent</p></li>
</ul>
<p>Cette propriété est très appréciée pour rechercher et insérer des données complexes. Admettons que l'on a un registre patient du type :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">patient</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">id</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">firstname</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">lastname</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">age</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">node</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">patient</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">node</span><span class="o">*</span><span class="w"> </span><span class="n">left</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">node</span><span class="o">*</span><span class="w"> </span><span class="n">right</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">Node</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Si l'on cherche le patient numéro <code class="docutils literal notranslate"><span class="pre">612</span></code>, il suffit de parcourir l'arbre de façon dichotomique :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="nf">search</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">node</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">node</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">search</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span><span class="w"> </span><span class="n">id</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>L'insertion et la suppression d'éléments dans un arbre binaire fait appel à des <a class="reference external" href="https://fr.wikipedia.org/wiki/Rotation_d%27un_arbre_binaire_de_recherche">rotations</a>, puisque les éléments doivent être insérés dans le correct ordre et que l'arbre, pour être performant doit toujours être équilibré. Ces rotations sont donc des mécanismes de rééquilibrage de l'arbre ne sont pas triviaux, mais dont la complexité d'exécution reste simple, et donc performante.</p>
</div>
<div class="section" id="heap">
<h2><span class="section-number">21.8  </span>Heap<a class="headerlink" href="#heap" title="Lien permanent vers ce titre">¶</a></h2>
<p>La structure de donnée <code class="docutils literal notranslate"><span class="pre">heap</span></code> aussi nommée tas ne doit pas être confondue avec le tas utilisé en allocation dynamique. Il s'agit d'une forme particulière de l'arbre binaire dit &quot;presque complet&quot;, dans lequel la différence de niveau entre les feuilles n'excède pas 1. C'est-à-dire que toutes les feuilles sont à une distance identique de la racine plus ou moins 1.</p>
<p>Un tas peut aisément être représenté sous forme de tableau en utilisant la règle suivante :</p>
<table class="docutils align-default" id="id15">
<caption><span class="caption-number">Tableau 21.3 </span><span class="caption-text">Opération d'accès à un élément d'un <em>heap</em></span><a class="headerlink" href="#id15" title="Lien permanent vers ce tableau">¶</a></caption>
<colgroup>
<col style="width: 27%" />
<col style="width: 37%" />
<col style="width: 37%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Cible</p></th>
<th class="head"><p>Début à 0</p></th>
<th class="head"><p>Début à 1</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Enfant de gauche</p></td>
<td><p><span class="math notranslate nohighlight">\(2*k  + 1\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(2 * k\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>Enfant de droite</p></td>
<td><p><span class="math notranslate nohighlight">\(2*k  + 2\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(2 * k + 1\)</span></p></td>
</tr>
<tr class="row-even"><td><p>Parent</p></td>
<td><p><span class="math notranslate nohighlight">\(floor(k-1) / 2\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(floor(k) / 2\)</span></p></td>
</tr>
</tbody>
</table>
<div class="figure align-default" id="id16">
<a class="reference internal image-reference" href="../_images/heap.svg"><img alt="../_images/heap.svg" height="321" src="../_images/heap.svg" width="326" /></a>
<p class="caption"><span class="caption-number">Fig. 21.13 </span><span class="caption-text">Représentation d'un <em>heap</em></span><a class="headerlink" href="#id16" title="Lien permanent vers cette image">¶</a></p>
</div>
</div>
<div class="section" id="queue-prioritaire">
<h2><span class="section-number">21.9  </span>Queue prioritaire<a class="headerlink" href="#queue-prioritaire" title="Lien permanent vers ce titre">¶</a></h2>
<p id="index-10">Une queue prioritaire ou <em>priority queue</em>, est une queue dans laquelle les éléments sont traités par ordre de priorité. Imaginons des personnalités, toutes atteintes d'une rage de dents et qui font la queue chez un dentiste aux mœurs discutables. Ce dernier ne prendra pas ses patients par ordre d'arrivée, mais, par importance aristocratique.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">Person</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="k">enum</span><span class="w"> </span><span class="n">SocialStatus</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">       </span><span class="n">PEON</span><span class="p">;</span><span class="w"></span>
<span class="w">       </span><span class="n">WORKER</span><span class="p">;</span><span class="w"></span>
<span class="w">       </span><span class="n">ENGINEER</span><span class="p">;</span><span class="w"></span>
<span class="w">       </span><span class="n">DOCTOR</span><span class="p">;</span><span class="w"></span>
<span class="w">       </span><span class="n">PROFESSOR</span><span class="p">;</span><span class="w"></span>
<span class="w">       </span><span class="n">PRESIDENT</span><span class="p">;</span><span class="w"></span>
<span class="w">       </span><span class="n">SUPERHERO</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"> </span><span class="n">status</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">Person</span><span class="p">;</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ProrityQueue</span><span class="w"> </span><span class="n">queue</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">queue_init</span><span class="p">(</span><span class="n">queue</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">       </span><span class="n">queue_enqueue</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">Person</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">random_name</span><span class="p">(),</span><span class="w"></span>
<span class="w">          </span><span class="p">.</span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">random_status</span><span class="p">()</span><span class="w"></span>
<span class="w">       </span><span class="p">});</span><span class="w"></span>

<span class="w">       </span><span class="n">Person</span><span class="w"> </span><span class="n">person</span><span class="p">;</span><span class="w"></span>
<span class="w">       </span><span class="n">queue_dequeue</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">person</span><span class="p">);</span><span class="w"></span>
<span class="w">       </span><span class="n">dentist_heal</span><span class="p">(</span><span class="n">person</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>La queue prioritaire dispose donc aussi des méthodes <code class="docutils literal notranslate"><span class="pre">enqueue</span></code> et <code class="docutils literal notranslate"><span class="pre">dequeue</span></code> mais le <code class="docutils literal notranslate"><span class="pre">dequeue</span></code> retournera l'élément le plus prioritaire de la liste. Ceci se traduit par trier la file d'attente à chaque opération <code class="docutils literal notranslate"><span class="pre">enqueue</span></code> ou <code class="docutils literal notranslate"><span class="pre">dequeue</span></code>. L'une de ces deux opérations pourrait donc avoir une complexité de <span class="math notranslate nohighlight">\(O(n log n)\)</span>. Heureusement, il existe méthodes de tris performantes si un tableau est déjà trié et qu'un seul nouvel élément y est ajouté.</p>
<p>L'implémentation de ce type de structure de donnée s'appuie le plus souvent sur un <em>heap</em>, soit construit à partir d'un tableau statique, soit un tableau dynamique.</p>
</div>
<div class="section" id="tableau-de-hachage">
<h2><span class="section-number">21.10  </span>Tableau de Hachage<a class="headerlink" href="#tableau-de-hachage" title="Lien permanent vers ce titre">¶</a></h2>
<p>Les tableaux de hachage (<em>Hash Table</em>) sont une structure particulière dans laquelle une fonction dite de <em>hachage</em> est utilisée pour transformer les entrées en des indices d'un tableau.</p>
<p>L'objectif est de stocker des chaînes de caractères correspondant a des noms simples ici utilisés pour l'exemple. Une possible répartition serait la suivante :</p>
<div class="figure align-default" id="id17">
<img alt="../_images/hash-linear.svg" src="../_images/hash-linear.svg" /><p class="caption"><span class="caption-number">Fig. 21.14 </span><span class="caption-text">Tableau de hachage simple</span><a class="headerlink" href="#id17" title="Lien permanent vers cette image">¶</a></p>
</div>
<p>Si l'on cherche l'indice correspondant à <code class="docutils literal notranslate"><span class="pre">Ada</span></code>, il convient de pouvoir calculer la valeur de l'indice correspondant à partir de la valeur de la chaîne de caractère. Pour calculer cet indice aussi appelé <em>hash</em>, il existe une infinité de méthodes. Dans cet exemple, considérons une méthode simple. Chaque lettre est identifiée par sa valeur ASCII et la somme de toutes les valeurs ASCII est calculée. Le modulo 10 est ensuite calculé sur cette somme pour obtenir une valeur entre 0 et 9. Ainsi nous avons les calculs suivants :</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">Nom    Valeurs ASCII     Somme  Modulo 10</span>
<span class="go">---    --------------    -----  ---------</span>
<span class="go">Mia -&gt; {77, 105, 97}  -&gt; 279 -&gt; 4</span>
<span class="go">Tim -&gt; {84, 105, 109} -&gt; 298 -&gt; 1</span>
<span class="go">Bea -&gt; {66, 101, 97}  -&gt; 264 -&gt; 0</span>
<span class="go">Zoe -&gt; {90, 111, 101} -&gt; 302 -&gt; 5</span>
<span class="go">Jan -&gt; {74, 97, 110}  -&gt; 281 -&gt; 6</span>
<span class="go">Ada -&gt; {65, 100, 97}  -&gt; 262 -&gt; 9</span>
<span class="go">Leo -&gt; {76, 101, 111} -&gt; 288 -&gt; 2</span>
<span class="go">Sam -&gt; {83, 97, 109}  -&gt; 289 -&gt; 3</span>
<span class="go">Lou -&gt; {76, 111, 117} -&gt; 304 -&gt; 7</span>
<span class="go">Max -&gt; {77, 97, 120}  -&gt; 294 -&gt; 8</span>
<span class="go">Ted -&gt; {84, 101, 100} -&gt; 285 -&gt; 10</span>
</pre></div>
</div>
<p>Pour trouver l'indice de <code class="docutils literal notranslate"><span class="pre">&quot;Mia&quot;</span></code> il suffit donc d'appeler la fonction suivante :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">hash_str</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="sc">&#39;\0&#39;</span><span class="p">)</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">s</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>L'assertion suivante est donc vraie :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">assert</span><span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="n">hash_str</span><span class="p">(</span><span class="s">&quot;Mia&quot;</span><span class="p">)],</span><span class="w"> </span><span class="s">&quot;Mia&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Rechercher <code class="docutils literal notranslate"><span class="pre">&quot;Mia&quot;</span></code> et obtenir <code class="docutils literal notranslate"><span class="pre">&quot;Mia&quot;</span></code> n'est certainement pas l'exemple le plus utile. Néanmoins il est possible d'encoder plus qu'une chaîne de caractère et utiliser plutôt une structure de donnée :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">Person</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">name</span><span class="p">[</span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="cm">/* &#39;\0&#39; */</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">month</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">day</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">year</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">born</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">JOB_ASTRONOMER</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">JOB_INVENTOR</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">JOB_ACTRESS</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">JOB_LOGICIAN</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">JOB_BIOLOGIST</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">job</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">country_code</span><span class="p">;</span><span class="w"> </span><span class="c1">// For example 41 for Switzerland</span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>Dans ce cas, le calcul du hash se ferait sur la première clé d'un élément :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">hash_person</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">Person</span><span class="w"> </span><span class="n">person</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">person</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="sc">&#39;\0&#39;</span><span class="p">)</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">s</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>L'accès à une personne à partir de la clé se résous donc en <code class="docutils literal notranslate"><span class="pre">O(1)</span></code> car il n'y a aucune itération ou recherche à effectuer.</p>
<p>Cette <a class="reference external" href="https://www.youtube.com/watch?v=KyUTuwz_b7Q">vidéo</a> YouTube explique bien le fonctionnement des tableaux de hachage.</p>
<div class="section" id="collisions">
<h3><span class="section-number">21.10.1  </span>Collisions<a class="headerlink" href="#collisions" title="Lien permanent vers ce titre">¶</a></h3>
<p id="index-11">Lorsque la :index`fonction de hachage` est mal choisie, un certain nombre de collisions peuvent apparaître. Si l'on souhaite par exemple ajouter les personnes suivantes :</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Sue -&gt; {83, 117, 101} -&gt; 301 -&gt; 4
Len -&gt; {76, 101, 110} -&gt; 287 -&gt; 1
</pre></div>
</div>
<p>On voit que les positions <code class="docutils literal notranslate"><span class="pre">4</span></code> et <code class="docutils literal notranslate"><span class="pre">1</span></code> sont déjà occupées par Mia et Tim.</p>
<p>Une stratégie de résolution s'appelle <a class="reference external" href="https://en.wikipedia.org/wiki/Open_addressing">Open adressing</a>. Parmi les possibilités de cette stratégie le <em>linear probing</em> consiste à vérifier si la position du tableau est déjà occupée et en cas de collision, chercher la prochaine place disponible dans le tableau :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">Person</span><span class="w"> </span><span class="n">people</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">}</span><span class="w"></span>

<span class="c1">// Add Mia</span>
<span class="n">Person</span><span class="w"> </span><span class="n">mia</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{.</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;Mia&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">born</span><span class="o">=</span><span class="p">{.</span><span class="n">day</span><span class="o">=</span><span class="mi">1</span><span class="p">,.</span><span class="n">month</span><span class="o">=</span><span class="mi">4</span><span class="p">,.</span><span class="n">year</span><span class="o">=</span><span class="mi">1991</span><span class="p">}};</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hash_person</span><span class="p">(</span><span class="n">mia</span><span class="p">);</span><span class="w"></span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">people</span><span class="p">[</span><span class="n">hash</span><span class="p">].</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="sc">&#39;\0&#39;</span><span class="p">)</span><span class="w"> </span><span class="n">hash</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="n">people</span><span class="p">[</span><span class="n">hash</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mia</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Récupérer une valeur dans le tableau demande une comparaison supplémentaire :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">char</span><span class="w"> </span><span class="n">key</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Mia&quot;</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hash_str</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="w"></span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">people</span><span class="p">[</span><span class="n">hash</span><span class="p">],</span><span class="w"> </span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">hash</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="n">Person</span><span class="w"> </span><span class="n">person</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">people</span><span class="p">[</span><span class="n">hash</span><span class="p">];</span><span class="w"></span>
</pre></div>
</div>
<p>Lorsque le nombre de collisions est négligeable par rapport à la table de hachage la recherche d'un élément est toujours en moyenne égale à <span class="math notranslate nohighlight">\(O(1)\)</span>, mais lorsque le nombre de collisions est prépondérant, la complexité se rapproche de celle de la recherche linéaire <span class="math notranslate nohighlight">\(O(n)\)</span> et on perd tout avantage à cette structure de donnée.</p>
<p>Dans le cas extrême, pour garantir un accès unitaire pour tous les noms de trois lettres, il faudrait un tableau de hachage d'une taille <span class="math notranslate nohighlight">\(26^3 = 17576\)</span> personnes. L'empreinte mémoire peut être considérablement réduite en stockant non pas une structure <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Person</span></code> mais plutôt l'adresse vers cette structure :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">Person</span><span class="w"> </span><span class="o">*</span><span class="n">people</span><span class="p">[</span><span class="mi">26</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">26</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">26</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>Dans ce cas exagéré, la fonction de hachage pourrait être la suivante :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">hash_name</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="n">name</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">26</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="sc">&#39;A&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">26</span><span class="w"> </span><span class="o">+</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">26</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">26</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="facteur-de-charge">
<h3><span class="section-number">21.10.2  </span>Facteur de charge<a class="headerlink" href="#facteur-de-charge" title="Lien permanent vers ce titre">¶</a></h3>
<p>Le <span class="target" id="index-12"></span>facteur de charge d'une table de hachage est donné par la relation :</p>
<div class="math notranslate nohighlight">
\[\text{Facteur de charge} = \frac{\text{Nombre total d'éléments}}{\text{Taille de la table}}\]</div>
<p>Plus ce facteur de charge est élevé, dans le cas du <em>linear probing</em>, moins bon sera performance de la table de hachage.</p>
<p>Certains algorithmes permettent de redimensionner dynamiquement la table de hachage pour conserver un facteur de charge le plus faible possible.</p>
</div>
<div class="section" id="chainage">
<h3><span class="section-number">21.10.3  </span>Chaînage<a class="headerlink" href="#chainage" title="Lien permanent vers ce titre">¶</a></h3>
<p>Le <span class="target" id="index-13"></span>chaînage ou <em>chaining</em> est une autre méthode pour mieux gérer les collisions. La table de hachage est couplée à une liste chaînée.</p>
<div class="figure align-default" id="id18">
<img alt="../_images/hash-table.svg" src="../_images/hash-table.svg" /><p class="caption"><span class="caption-number">Fig. 21.15 </span><span class="caption-text">Chaînage d'une table de hachage</span><a class="headerlink" href="#id18" title="Lien permanent vers cette image">¶</a></p>
</div>
</div>
<div class="section" id="fonction-de-hachage">
<h3><span class="section-number">21.10.4  </span>Fonction de hachage<a class="headerlink" href="#fonction-de-hachage" title="Lien permanent vers ce titre">¶</a></h3>
<p>Nous avons vu plus haut une fonction de hachage calculant le modulo sur la somme des caractères ASCII d'une chaîne de caractères. Nous avons également vu que cette fonction de hachage est source de nombreuses collisions. Les chaînes <code class="docutils literal notranslate"><span class="pre">&quot;Rea&quot;</span></code> ou <code class="docutils literal notranslate"><span class="pre">&quot;Rae&quot;</span></code> auront les même <em>hash</em> puisqu'ils contiennent les mêmes lettres. De même une fonction de hachage qui ne répartit pas bien les éléments dans la table de hachage sera mauvaise. On sait par exemple que les voyelles sont nombreuses dans les mots et qu'il n'y en a que six et que la probabilité que nos noms de trois lettres contiennent une voyelle en leur milieu est très élevée.</p>
<p>L'idée générale des fonctions de hachage est de répartir <strong>uniformément</strong> les clés sur les indices de la table de hachage. L'approche la plus courante est de mélanger les bits de notre clé dans un processus reproductible.</p>
<p>Une idée <strong>mauvaise</strong> et <strong>à ne pas retenir</strong> pourrait être d'utiliser le caractère pseudo-aléatoire de <code class="docutils literal notranslate"><span class="pre">rand</span></code> pour hacher nos noms :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">hash</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">str</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">mod</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">str</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="sc">&#39;\0&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">srand</span><span class="p">(</span><span class="n">h</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">*</span><span class="n">str</span><span class="o">++</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rand</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">mod</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">names</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;Bea&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Tim&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Len&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Sam&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Ada&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Mia&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;Sue&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Zoe&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Rae&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Lou&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Max&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Tod&quot;</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">names</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">names</span><span class="p">);</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s : %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">hash</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="mi">10</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Cette approche nous donne une assez bonne répartition :</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>./a.out
<span class="go">Bea : 2</span>
<span class="go">Tim : 3</span>
<span class="go">Len : 0</span>
<span class="go">Sam : 3</span>
<span class="go">Ada : 4</span>
<span class="go">Mia : 3</span>
<span class="go">Sue : 6</span>
<span class="go">Zoe : 5</span>
<span class="go">Rae : 8</span>
<span class="go">Lou : 0</span>
<span class="go">Max : 3</span>
<span class="go">Tod : 1</span>
</pre></div>
</div>
<p>Dans la pratique, on utilisera volontiers des fonctions de hachage utilisées en cryptographies tels que <a class="reference external" href="https://en.wikipedia.org/wiki/MD5">MD5</a> ou <cite>SHA</cite>. Considérons par exemple la première partie du poème Chanson de Pierre Corneille :</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>cat chanson.txt
<span class="go">Si je perds bien des maîtresses,</span>
<span class="go">J&#39;en fais encor plus souvent,</span>
<span class="go">Et mes voeux et mes promesses</span>
<span class="go">Ne sont que feintes caresses,</span>
<span class="go">Et mes voeux et mes promesses</span>
<span class="go">Ne sont jamais que du vent.</span>

<span class="gp">$ </span>md5sum chanson.txt
<span class="go">699bfc5c3fd42a06e99797bfa635f410  chanson.txt</span>
</pre></div>
</div>
<p>Le <em>hash</em> de ce texte est exprimé en hexadécimal ( <code class="docutils literal notranslate"><span class="pre">0x699bfc5c3fd42a06e99797bfa635f410</span></code>). Converti en décimal <code class="docutils literal notranslate"><span class="pre">140378864046454182829995736237591622672</span></code> il peut être réduit en utilisant le modulo. Voici un exemple en C :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;openssl/md5.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">hash</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">str</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">mod</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Compute MD5</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">output</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">MD5_CTX</span><span class="w"> </span><span class="n">md5</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">MD5_Init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">md5</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">MD5_Update</span><span class="p">(</span><span class="o">&amp;</span><span class="n">md5</span><span class="p">,</span><span class="w"> </span><span class="n">str</span><span class="p">,</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="n">MD5_Final</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">output</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">md5</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// 128-bits --&gt; 32-bits</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">output</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">output</span><span class="p">);</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">h</span><span class="w"> </span><span class="o">^=</span><span class="w"> </span><span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// 32-bits --&gt; mod</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">mod</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">text</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;La poule ou l&#39;oeuf?&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;Les pommes sont cuites!&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;Aussi lentement que possible&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;La poule ou l&#39;oeuf.&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;La poule ou l&#39;oeuf!&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;Aussi vite que nécessaire&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;Il ne faut pas lâcher la proie pour l’ombre.&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;Le mieux est l&#39;ennemi du bien&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">text</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">text</span><span class="p">);</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;% 2d. %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">hash</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="mi">10</span><span class="p">),</span><span class="w"> </span><span class="n">text</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>gcc hash.c -lcrypto
<span class="gp">$ </span>./a.out
<span class="go">1. La poule ou l&#39;oeuf?</span>
<span class="go">2. Les pommes sont cuites!</span>
<span class="go">3. Aussi lentement que possible</span>
<span class="go">4. La poule ou l&#39;oeuf.</span>
<span class="go">5. La poule ou l&#39;oeuf!</span>
<span class="go">6. Aussi vite que nécessaire</span>
<span class="go">8. Il ne faut pas lâcher la proie pour l’ombre.</span>
<span class="go">9. Le mieux est l&#39;ennemi du bien</span>
</pre></div>
</div>
<p>On peut constater qu'ici les indices sont bien répartis et que la fonction de hachage choisie semble uniforme.</p>
</div>
</div>
<div class="section" id="piles-ou-lifo-last-in-first-out">
<h2><span class="section-number">21.11  </span>Piles ou LIFO (<em>Last In First Out</em>)<a class="headerlink" href="#piles-ou-lifo-last-in-first-out" title="Lien permanent vers ce titre">¶</a></h2>
<p>Une pile est une structure de donnée très similaire à un tableau dynamique, mais dans laquelle les opérations sont limitées. Par exemple, il n'est possible que :</p>
<ul class="simple">
<li><p>d'ajouter un élément (<em>push</em>) ;</p></li>
<li><p>retirer un élément (<em>pop</em>) ;</p></li>
<li><p>obtenir le dernier élément ajouté (<em>peek</em>) ;</p></li>
<li><p>tester si la pile est vide (<em>is_empty</em>) ;</p></li>
<li><p>tester si la pile est pleine avec (<em>is_full</em>).</p></li>
</ul>
<p>Une utilisation possible de pile sur des entiers serait la suivante :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;stack.h&quot;</span><span class="cp"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Stack</span><span class="w"> </span><span class="n">stack</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">stack_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stack</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">stack_push</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">stack_peek</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">42</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">stack_push</span><span class="p">(</span><span class="mi">23</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">stack_is_empty</span><span class="p">());</span><span class="w"></span>

<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">stack_pop</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">23</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">stack_pop</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">42</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">stack_is_empty</span><span class="p">());</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Les piles peuvent être implémentées avec des tableaux dynamiques ou des listes chaînées (voir plus bas).</p>
</div>
<div class="section" id="queues-ou-fifo-first-in-first-out">
<h2><span class="section-number">21.12  </span>Queues ou FIFO (<em>First In First Out</em>)<a class="headerlink" href="#queues-ou-fifo-first-in-first-out" title="Lien permanent vers ce titre">¶</a></h2>
<p>Les queues sont aussi des structures très similaires à des tableaux dynamiques, mais elles ne permettent que les opérations suivantes :</p>
<ul class="simple">
<li><p>ajouter un élément à la queue (<em>push</em>) aussi nommé <em>enqueue</em> ;</p></li>
<li><p>supprimer un élément au début de la queue (<em>shift</em>) aussi nommé <em>dequeue</em> ;</p></li>
<li><p>tester si la queue est vide (<em>is_empty</em>) ;</p></li>
<li><p>tester si la queue est pleine avec (<em>is_full</em>).</p></li>
</ul>
<p>Les queues sont souvent utilisées lorsque des processus séquentiels ou parallèles s'échangent des tâches à traiter :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#include &quot;queue.h&quot;
#include &lt;stdio.h&gt;

void get_work(Queue *queue) {
    while (!feof(stdin)) {
        int n;
        if (scanf(&quot;%d&quot;, &amp;n) == 1)
            queue_enqueue(n);
        scanf(&quot;%*[^\n]%[\n]&quot;);
    }
}

void process_work(Queue *queue) {
    while (!is_empty(queue)) {
        int n = queue_dequeue(queue);
        printf(&quot;%d est %s\n&quot;, n, n % 2 ? &quot;impair&quot; : &quot;pair&quot;;
    }
}

int main() {
    Queue* queue;

    queue_init(&amp;queue);
    get_work(queue);
    process_work(queue);
    queue_free(queue);
}
</pre></div>
</div>
</div>
<div class="section" id="performances">
<h2><span class="section-number">21.13  </span>Performances<a class="headerlink" href="#performances" title="Lien permanent vers ce titre">¶</a></h2>
<p>Les différentes structures de données ne sont pas toutes équivalentes en termes de performances. Il convient, selon l'application, d'opter pour la structure la plus adaptée, et par conséquent il est important de pouvoir comparer les différentes structures de données pour choisir la plus appropriée. Est-ce que les données doivent être maintenues triées ? Est-ce que la structure de donnée est utilisée comme une pile ou un tas ? Quelle est la structure de donnée avec le moins d'<em>overhead</em> pour les opérations de <code class="docutils literal notranslate"><span class="pre">push</span></code> ou <code class="docutils literal notranslate"><span class="pre">unshift</span></code> ?</p>
<p>L'indexation (<em>indexing</em>) est l'accès à une certaine valeur du tableau par exemple avec <code class="docutils literal notranslate"><span class="pre">a[k]</span></code>. Dans un tableau statique et dynamique l'accès se fait par pointeur depuis le début du tableau soit : <code class="docutils literal notranslate"><span class="pre">*((char*)a</span> <span class="pre">+</span> <span class="pre">sizeof(a[0])</span> <span class="pre">*</span> <span class="pre">k)</span></code> qui est équivalant à <code class="docutils literal notranslate"><span class="pre">*(a</span> <span class="pre">+</span> <span class="pre">k)</span></code>. L'indexation par arithmétique de pointeur n'est pas possible avec les listes chaînées dont il faut parcourir chaque élément pour découvrir l'adresse du prochain élément :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">get</span><span class="p">(</span><span class="n">List</span><span class="w"> </span><span class="o">*</span><span class="n">list</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">List</span><span class="w"> </span><span class="o">*</span><span class="n">el</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">k</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">el</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">el</span><span class="p">.</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">el</span><span class="p">.</span><span class="n">value</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>L'indexation d'une liste chaînée prend dans le cas le plus défavorable <span class="math notranslate nohighlight">\(O(n)\)</span>.</p>
<p>Les arbres binaires ont une structure qui permet naturellement la dichotomique. Chercher l'élément 5 prend 4 opérations : <code class="docutils literal notranslate"><span class="pre">12</span> <span class="pre">-&gt;</span> <span class="pre">4</span> <span class="pre">-&gt;</span> <span class="pre">6</span> <span class="pre">-&gt;</span> <span class="pre">5</span></code>. L'indexation est ainsi possible en <span class="math notranslate nohighlight">\(O(log n)\)</span>.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>            12
             |
         ----+----
       /           \
      4            12
     --            --
   /    \        /    \
  2      6      10    14
 / \    / \    / \   /  \
1   3  5   7  9  11 13  15
</pre></div>
</div>
<p>Le tableau suivant résume les performances obtenues pour les différentes structures de données que nous avons vu dans ce chapitre :</p>
<table class="docutils align-default" id="id19">
<caption><span class="caption-number">Tableau 21.4 </span><span class="caption-text">Comparaison des performances des structures récursives</span><a class="headerlink" href="#id19" title="Lien permanent vers ce tableau">¶</a></caption>
<colgroup>
<col style="width: 19%" />
<col style="width: 14%" />
<col style="width: 16%" />
<col style="width: 12%" />
<col style="width: 14%" />
<col style="width: 12%" />
<col style="width: 13%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Action</p></th>
<th class="head" colspan="2"><p>Tableau</p></th>
<th class="head"><p>Liste</p></th>
<th class="head"><p>Buffer</p></th>
<th class="head"><p>Arbre</p></th>
<th class="head"><p>Hash Map</p></th>
</tr>
<tr class="row-even"><th class="head"><p>Nom</p></th>
<th class="head"><p>Statique</p></th>
<th class="head"><p>Dynamique</p></th>
<th class="head"><p>chaînée</p></th>
<th class="head"><p>circulaire</p></th>
<th class="head"><p>binaire</p></th>
<th class="head"><p>linéaire</p></th>
</tr>
</thead>
<tbody>
<tr class="row-odd"><td><p>Indexing</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>n</p></td>
<td><p>1</p></td>
<td><p>log n</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-even"><td><p>Unshift/Shift</p></td>
<td><p>n</p></td>
<td><p>n</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>log n</p></td>
<td><p>n</p></td>
</tr>
<tr class="row-odd"><td><p>Push/Pop</p></td>
<td><p>1</p></td>
<td><p>1 amorti</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>log n</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-even"><td><p>Insert/Delete</p></td>
<td><p>n</p></td>
<td><p>n</p></td>
<td><p>1</p></td>
<td><p>n</p></td>
<td><p>log n</p></td>
<td><p>n</p></td>
</tr>
<tr class="row-odd"><td><p>Search</p></td>
<td><p>n</p></td>
<td><p>n</p></td>
<td><p>n</p></td>
<td><p>n</p></td>
<td><p>log n</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-even"><td><p>Sort</p></td>
<td><p>n log n</p></td>
<td><p>n log n</p></td>
<td><p>n log n</p></td>
<td><p>n log n</p></td>
<td><p>1</p></td>
<td><p><em>n/a</em></p></td>
</tr>
</tbody>
</table>
</div>
</div>


          </div>
          <div class="page-nav">
            <div class="inner"><ul class="page-nav">
  <li class="prev">
    <a href="testing.html"
       title="Chapitre précédent">← <span class="section-number">20  </span>Qualité et Testabilité</a>
  </li>
  <li class="next">
    <a href="advanced-topics.html"
       title="Chapitre suivant"><span class="section-number">22  </span>Avancé →</a>
  </li>
</ul><div class="footer" role="contentinfo">
      &#169; Copyright HEIG-VD(c) 2022.
    Mis à jour le 18 févr. 2022 (version v0.3.0-31-gcddb9f1).
    <br>
    Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.2.1 with <a href="https://github.com/heig-vd-tin/sphinx_heigvd_theme">HEIG-VD Theme</a>.
</div>
            </div>
          </div>
      </page>
    </div>
    
    
  </body>
</html>