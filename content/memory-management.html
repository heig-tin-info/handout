<!DOCTYPE html>
<html  lang="fr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <style type="text/css">
        p.rubric {
            font-weight: bold;
        }

        p.rubric:hover > a.headerlink {
            visibility: visible;
        }
    </style>
    
      <title>13 Gestion de la mémoire</title>
    
      <link rel="stylesheet" href="../_static/pygments.css">
      <link rel="stylesheet" href="../_static/theme.css">
      
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>

      <!-- sphinx script_files -->
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="../_static/translations.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>

      
      <script src="../_static/theme-vendors.js"></script>
      <script src="../_static/theme.js" defer></script>
    
    <link rel="icon" href="../_static/favicon.ico" type="image/x-icon" />
  <link rel="index" title="Index" href="../genindex.html" />
  <link rel="search" title="Recherche" href="../search.html" />
  <link rel="next" title="14 Pointeurs" href="pointers.html" />
  <link rel="prev" title="12 Les fichiers" href="files.html" /> 
  </head>

  <body>
    <div id="app" class="theme-container" :class="pageClasses"><navbar @toggle-sidebar="toggleSidebar">
  <router-link to="../index.html" class="home-link">
    
      <span class="site-name">Le C pour l&#39;ingénieur</span>
    
  </router-link>

  <div class="links">
    <navlinks class="can-hide">

  
    <div class="nav-item">
      <a href="../index.html#le-c-pour-l-ingenieur"
         class="nav-link  router-link-active">
         Table des matières
      </a>
    </div>
  
    <div class="nav-item">
      <a href="../index.html#le-c-pour-l-ingenieur"
         class="nav-link ">
         Annexes
      </a>
    </div>
  
    <div class="nav-item">
      <a href="../index.html#le-c-pour-l-ingenieur"
         class="nav-link ">
         Références
      </a>
    </div>
  



    </navlinks>
  </div>
</navbar>

      
      <div class="sidebar-mask" @click="toggleSidebar(false)">
      </div>
        <sidebar @toggle-sidebar="toggleSidebar">
          
          <navlinks>
            

  
    <div class="nav-item">
      <a href="../index.html#le-c-pour-l-ingenieur"
         class="nav-link  router-link-active">
         Table des matières
      </a>
    </div>
  
    <div class="nav-item">
      <a href="../index.html#le-c-pour-l-ingenieur"
         class="nav-link ">
         Annexes
      </a>
    </div>
  
    <div class="nav-item">
      <a href="../index.html#le-c-pour-l-ingenieur"
         class="nav-link ">
         Références
      </a>
    </div>
  



            
          </navlinks><div id="searchbox" class="searchbox" role="search">
  <div class="caption"><span class="caption-text">Recherche rapide</span>
    <div class="searchformwrapper">
      <form class="search" action="../search.html" method="get">
        <input type="text" name="q" />
        <input type="submit" value="Recherche" />
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div><div class="sidebar-links" role="navigation" aria-label="main navigation">
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="../index.html#le-c-pour-l-ingenieur">Table des matières</a></span>
      </p>
      <ul class="current">
        
          <li class="toctree-l1 "><a href="introduction.html" class="reference internal ">Introduction</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="programming.html" class="reference internal ">La programmation</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="foundations.html" class="reference internal ">Généralités du langage</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="numeration.html" class="reference internal ">Numération</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="operators.html" class="reference internal ">Opérateurs</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="datatype.html" class="reference internal ">Types de données</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="control-structures.html" class="reference internal ">Structures de contrôle</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="processus.html" class="reference internal ">Programmes et Processus</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="stdio.html" class="reference internal ">Entrées Sorties</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="functions.html" class="reference internal ">Fonctions</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="composite-datatypes.html" class="reference internal ">Types composites</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="files.html" class="reference internal ">Les  fichiers</a>

            
          </li>

        
          <li class="toctree-l1 current"><a href="#" class="reference internal current">Gestion de la mémoire</a>

            
              <ul>
                
                  <li class="toctree-l2"><a href="#allocation-statique" class="reference internal">Allocation statique</a></li>
                
                  <li class="toctree-l2"><a href="#allocation-dynamique" class="reference internal">Allocation dynamique</a></li>
                
                  <li class="toctree-l2"><a href="#memoire-de-programme" class="reference internal">Mémoire de programme</a></li>
                
                  <li class="toctree-l2"><a href="#la-pile" class="reference internal">La pile</a></li>
                
                  <li class="toctree-l2"><a href="#allocation-dynamique-sur-le-tas" class="reference internal">Allocation dynamique sur le tas</a></li>
                
                  <li class="toctree-l2"><a href="#variables-automatiques" class="reference internal">Variables automatiques</a></li>
                
                  <li class="toctree-l2"><a href="#fragmentation-memoire" class="reference internal">Fragmentation mémoire</a></li>
                
              </ul>
            
          </li>

        
          <li class="toctree-l1 "><a href="pointers.html" class="reference internal ">Pointeurs</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="standard-library.html" class="reference internal ">Bibliothèques</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="preprocessor.html" class="reference internal ">Préprocesseur</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="algorithms.html" class="reference internal ">Algorithmes et conception</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="translation-units.html" class="reference internal ">Compilation séparée</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="scopes.html" class="reference internal ">Portée et visibilité</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="testing.html" class="reference internal ">Qualité et Testabilité</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="data-structures.html" class="reference internal ">Structures de données</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="advanced-topics.html" class="reference internal ">Avancé</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="traps.html" class="reference internal ">Pièges</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="philosophy.html" class="reference internal ">Philosophie</a>

            
          </li>

        
      </ul>
    </div>
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="../index.html#le-c-pour-l-ingenieur">Annexes</a></span>
      </p>
      <ul class="">
        
          <li class="toctree-l1 "><a href="../appendix/vscode.html" class="reference internal ">Visual Studio Code</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="../appendix/grammar.html" class="reference internal ">Grammaire C</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="../appendix/bash.html" class="reference internal ">Ligne de commande</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="../appendix/development.html" class="reference internal ">Environnement de développement</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="../appendix/unit.html" class="reference internal ">Fiches d'unités de cours</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="../appendix/laboratories.html" class="reference internal ">Laboratoires</a>

            
          </li>

        
      </ul>
    </div>
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="../index.html#le-c-pour-l-ingenieur">Références</a></span>
      </p>
      <ul class="">
        
          <li class="toctree-l1 "><a href="../backmatter/exercises.html" class="reference internal ">Solution des exercices</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="../backmatter/bibliography.html" class="reference internal ">Bibliographie</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="../backmatter/glossary.html" class="reference internal ">Glossaire</a>

            
          </li>

        
      </ul>
    </div>
  
</div>
        </sidebar>

      <page>
          <div class="body-header" role="navigation" aria-label="navigation">
  
  <ul class="breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
    
    <li><span class="section-number">13  </span>Gestion de la mémoire</li>
  </ul>
  

  <ul class="page-nav">
  <li class="prev">
    <a href="files.html"
       title="Chapitre précédent">← <span class="section-number">12  </span>Les  fichiers</a>
  </li>
  <li class="next">
    <a href="pointers.html"
       title="Chapitre suivant"><span class="section-number">14  </span>Pointeurs →</a>
  </li>
</ul>
  
</div>
<hr>
          <div class="content" role="main">
            
  <div class="section" id="gestion-de-la-memoire">
<span id="memory-management"></span><h1><span class="section-number">13  </span>Gestion de la mémoire<a class="headerlink" href="#gestion-de-la-memoire" title="Lien permanent vers ce titre">¶</a></h1>
<p>Vous l'aurez appris à vos dépens, l'erreur <em>Segmentation fault</em> (erreur de segmentation) arrive souvent lors du développement. Ce chapitre s'intéresse à la mémoire et vulgarise les concepts de segmentation et traite de l'allocation dynamique.</p>
<p>La mémoire d'un programme est découpée en <a class="reference external" href="https://fr.wikipedia.org/wiki/Segment_de_donn%C3%A9es">segments de données</a>. Les principaux segments sont :</p>
<table class="colwidths-given docutils align-default" id="id1">
<caption><span class="caption-number">Tableau 13.1 </span><span class="caption-text">Segments mémoire</span><a class="headerlink" href="#id1" title="Lien permanent vers ce tableau">¶</a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 30%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Segment</p></th>
<th class="head"><p>Nom</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.text</span></code></p></td>
<td><p>Segment de code</p></td>
<td><p>Les instructions du programme exécutable sont chargées dans ce segment.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">.rodata</span></code></p></td>
<td><p>Segment de constantes et chaînes de caractères</p></td>
<td><p>Les constantes globales <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">13</span></code> et les chaînes de caractères sont enregistrées dans ce segment.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.bss</span></code></p></td>
<td><p>Segment de variables initialisées</p></td>
<td><p>Ce segment est garanti d'être initialisé à zéro lorsque le programme est chargé en mémoire. Les variables globales statiques tels que <code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">int</span> <span class="pre">foo</span> <span class="pre">=</span> <span class="pre">0</span></code> seront stockées dans ce segment.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">.data</span></code></p></td>
<td><p>Segment de variables non initialisées</p></td>
<td><p>Les variables globales non initialisées comme <code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">int</span> <span class="pre">bar;</span></code> seront placées dans ce segment.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.heap</span></code></p></td>
<td><p>Segment de tas</p></td>
<td><p>Les allocations dynamiques décrites plus bas dans ce chapitre sont déclarées ici.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">.stack</span></code></p></td>
<td><p>Segment de pile</p></td>
<td><p>La chaîne d'appel de fonction ainsi que toutes les variables locales sont mémorisées dans ce segment.</p></td>
</tr>
</tbody>
</table>
<div class="section" id="allocation-statique">
<h2><span class="section-number">13.1  </span>Allocation statique<a class="headerlink" href="#allocation-statique" title="Lien permanent vers ce titre">¶</a></h2>
<p>Jusqu'ici toutes les variables que nous avons déclarées ont été déclarées statiquement. C'est-à-dire que le compilateur est capable a priori de savoir combien de place prend telle ou telle variable et les agencer en mémoire dans les bons segments. On appelle cette méthode d'allocation de mémoire l'allocation statique.</p>
<p>La <a class="reference external" href="https://fr.wikipedia.org/wiki/Allocation_de_m%C3%A9moire#Allocation_statique">déclaration statique</a> suivante déclare un tableau de 1024 entiers 64-bits initialisés à zéro et stockés dans le segment <code class="docutils literal notranslate"><span class="pre">.bss</span></code>, soit 64 kio :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">static</span> <span class="n">int64_t</span> <span class="n">vector</span><span class="p">[</span><span class="mi">1024</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="allocation-dynamique">
<h2><span class="section-number">13.2  </span>Allocation dynamique<a class="headerlink" href="#allocation-dynamique" title="Lien permanent vers ce titre">¶</a></h2>
<p>Il est des circonstances ou un programme ne sait pas combien de mémoire il a besoin. Par exemple un programme qui compterait le nombre d'occurrences de chaque mot dans un texte devra se construire un index de tous les mots qu'il découvre lors de la lecture du fichier d'entrée. A priori ce fichier d'entrée étant inconnu au moment de l'exécution du programme, l'espace mémoire nécessaire à construire ce dictionnaire de mots est également inconnu.</p>
<p>L'approche la plus naïve serait d'anticiper le cas le plus défavorable. Le dictionnaire Littré comporte environ 132'000 mots tandis que le Petit Larousse Illustré 80'000 mots environ. Pour se donner une bonne marge de manœuvre et anticiper les anglicismes et les noms propres. Il suffirait de réserver un tableau de 1 million de mots de 10 caractères soit un peu plus de 100 MiB de mémoire quand bien même le fichier qui serait lu ne comporterait que 2 mots: <code class="docutils literal notranslate"><span class="pre">Hello</span> <span class="pre">World!</span></code>.</p>
<p>L'approche correcte est d'allouer la mémoire au moment ou on en a besoin, c'est ce que l'on appelle l'<a class="reference external" href="https://fr.wikipedia.org/wiki/Tas_(allocation_dynamique)">allocation dynamique</a>.</p>
<p>Lorsqu'un programme à besoin de mémoire, il peut générer un appel système pour demander au système d'exploitation le besoin de disposer de plus de mémoire. En pratique on utilise deux fonctions de la bibliothèque standard <cite>&lt;stdlib.h&gt;</cite>:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*malloc(size_t</span> <span class="pre">size)</span></code></dt><dd><p>Alloue dynamiquement un espace mémoire de <code class="docutils literal notranslate"><span class="pre">size</span></code> bytes. Le terme <em>malloc</em> découle de <em>Memory ALLOCation</em>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*calloc(size_t</span> <span class="pre">nitems,</span> <span class="pre">size_t</span> <span class="pre">size)</span></code></dt><dd><p>Fonctionne de façon similaire à <code class="docutils literal notranslate"><span class="pre">malloc</span></code> mais initialise l'espace alloué à zéro.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">free(void</span> <span class="pre">*ptr)</span></code></dt><dd><p>Libère un espace préalablement alloué par <code class="docutils literal notranslate"><span class="pre">malloc</span></code> ou <code class="docutils literal notranslate"><span class="pre">calloc</span></code></p>
</dd>
</dl>
<p>L'allocation se fait sur le <cite>tas</cite> (<em>heap</em>) qui est de taille variable. À chaque fois qu'un espace mémoire est demandé, <code class="docutils literal notranslate"><span class="pre">malloc</span></code> recherche dans le segment un espace vide de taille suffisante, s'il ne parvient pas, il exécute l'appel système <a class="reference external" href="https://en.wikipedia.org/wiki/Sbrk">sbrk</a> qui permet de déplacer la frontière du segment mémoire et donc d'agrandir le segment.</p>
<div class="figure align-default" id="fig-allocation">
<img alt="../_images/malloc.svg" src="../_images/malloc.svg" /><p class="caption"><span class="caption-number">Fig. 13.1 </span><span class="caption-text">Allocation et libération mémoire</span><a class="headerlink" href="#fig-allocation" title="Lien permanent vers cette image">¶</a></p>
</div>
</div>
<div class="section" id="memoire-de-programme">
<h2><span class="section-number">13.3  </span>Mémoire de programme<a class="headerlink" href="#memoire-de-programme" title="Lien permanent vers ce titre">¶</a></h2>
<p>Les segments mémoires sont une construction de la bibliothèque standard, selon la bibliothèque utilisée et à fortiori le système d'exploitation utilisé, l'agencement mémoire peut varier.</p>
<p>Néanmoins une bonne représentation est la suivante :</p>
<div class="figure align-default" id="id2">
<a class="reference internal image-reference" href="../_images/program-memory.svg"><img alt="../_images/program-memory.svg" height="313" src="../_images/program-memory.svg" width="246" /></a>
<p class="caption"><span class="caption-number">Fig. 13.2 </span><span class="caption-text">Organisation de mémoire d'un programme</span><a class="headerlink" href="#id2" title="Lien permanent vers cette image">¶</a></p>
</div>
<p>On observe que le tas et la pile vont à leur rencontre, et que lorsqu'ils se percutent c'est le crash avec l'erreur bien connue <a class="reference external" href="https://fr.wikipedia.org/wiki/D%C3%A9passement_de_pile">stack overflow</a>.</p>
</div>
<div class="section" id="la-pile">
<h2><span class="section-number">13.4  </span>La pile<a class="headerlink" href="#la-pile" title="Lien permanent vers ce titre">¶</a></h2>
<p>Lorsqu'un programme s'exécute, l'ordre dont les fonctions s'exécutent n'est pas connu à priori. L'ordre d'exécution des fonctions dans l'exemple suivant est inconnu par le programme et donc les éventuelles variables locales utilisées par ces fonctions doivent dynamiquement être allouées.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>

<span class="kt">double</span><span class="w"> </span><span class="nf">square</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">num</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">num</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">double</span><span class="w"> </span><span class="nf">cube</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">num</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">num</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rand</span><span class="p">()</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">square</span><span class="p">(</span><span class="n">num</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cube</span><span class="p">(</span><span class="n">num</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">num</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Lors d'un appel de fonction, le compilateur ajoute avant la première instruction du code caché permettant d'empiler sur un espace mémoire dédié (<em>stack</em>) les variables locales dont il a besoin ainsi que certaines informations tel que l'adresse mémoire de retour.</p>
</div>
<div class="section" id="allocation-dynamique-sur-le-tas">
<h2><span class="section-number">13.5  </span>Allocation dynamique sur le tas<a class="headerlink" href="#allocation-dynamique-sur-le-tas" title="Lien permanent vers ce titre">¶</a></h2>
<p>L'allocation dynamique permet de réserver - lors de l'exécution - une
zone mémoire dont on vient de calculer la taille. On utilisera la
fonction <em>malloc</em> (memory allocation) pour réserver de la mémoire. Cette
fonction n'initialise pas la zone réservée.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="kt">size_t</span><span class="p">;</span><span class="w"></span>
<span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="nf">malloc</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Il est nécessaire d'inclure le fichier <em>stdlib.h</em> pour utiliser les
fonctions d'allocation mémoire. Par exemple, pour réserver un tableau de
n valeurs de type <em>double</em> :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"></span>
<span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">zone_acquisition</span><span class="p">;</span><span class="w"> </span><span class="c1">// pointeur sur la zone à réserver</span>

<span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w"></span>

<span class="n">zone_acquisition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span><span class="w"></span>
</pre></div>
</div>
<div class="section" id="allocation-dynamique-sur-le-tas-avec-mise-a-zero">
<h3><span class="section-number">13.5.1  </span>Allocation dynamique sur le tas avec mise à zéro<a class="headerlink" href="#allocation-dynamique-sur-le-tas-avec-mise-a-zero" title="Lien permanent vers ce titre">¶</a></h3>
<p>On utilisera la fonction <em>calloc</em> (memory allocation) pour réserver de
la mémoire avec initialisation automatique de la zone réservée.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">calloc</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Cette fonction réserve <em>count</em> x <em>size</em> octets en mémoire et
l'initialise à zéro.</p>
</div>
<div class="section" id="modification-de-la-taille-d-une-zone-deja-allouee-sur-le-tas">
<h3><span class="section-number">13.5.2  </span>Modification de la taille d'une zone déjà allouée sur le tas<a class="headerlink" href="#modification-de-la-taille-d-une-zone-deja-allouee-sur-le-tas" title="Lien permanent vers ce titre">¶</a></h3>
<p>Si l'on veut agrandir une zone déjà allouée avec <em>malloc</em> ou <em>calloc</em>,
on utilisera la fonction suivante :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">realloc</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Elle permet de :</p>
<ul class="simple">
<li><p>réallouer un bloc de mémoire avec une nouvelle taille</p></li>
<li><p>si ptr est NULL, créer un nouveau bloc</p></li>
<li><p>si la réallocation échoue, retourner NULL ; le bloc passé en
paramètre reste alors inchangé</p></li>
<li><p>en cas de succès, l'adresse retournée peut être différente de ptr ; le
bloc initialement pointé par ptr a alors été libéré</p></li>
<li><p>le bloc réalloué est initialisé avec le contenu du bloc ptr ;
l'espace supplémentaire est non initialisé</p></li>
</ul>
</div>
<div class="section" id="liberation">
<h3><span class="section-number">13.5.3  </span>Libération<a class="headerlink" href="#liberation" title="Lien permanent vers ce titre">¶</a></h3>
<p>Le tas n'étant pas extensible à l'infini, il faut libérer la mémoire dès
que l'on n'en a plus l'utilité.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">free</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">memblock</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Une fois libérée, la mémoire (donc son pointeur) ne doit plus être
utilisée sous peine de corrompre des données du système.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"></span>
<span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">zone_acquisition</span><span class="p">;</span><span class="w"> </span><span class="c1">// pointeur sur la zone à réserver</span>

<span class="n">n</span><span class="o">=</span><span class="mi">100</span><span class="p">;</span><span class="w"></span>

<span class="n">zone_acquisition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">malloc</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"></span>

<span class="c1">// utilisation...</span>

<span class="n">free</span><span class="p">(</span><span class="n">zone_acquisition</span><span class="p">);</span><span class="w"> </span><span class="c1">// libère la mémoire</span>
</pre></div>
</div>
<p>De la même manière, il ne faut pas libérer un bloc qui n'a pas été
alloué. Si on ne libère pas la mémoire, elle reste allouée pour
l'application et la zone disponible diminue. Il peut arriver qu'il ne
reste plus d'espace disponible pour l'allocation dynamique ; cela peut
entraver la bonne marche de l'ordinateur. Ce problème est souvent dû à
des erreurs de conception des applications qui ne libèrent pas tous les
blocs alloués ; on observe alors un phénomène de fuite mémoire qui cause
le plantage de la machine. Selon les fréquences d'allocation et de non
libération, ces problèmes peuvent survenir immédiatement, ou après
plusieurs jours de fonctionnement, ce qui complique grandement les
opérations de debug...</p>
</div>
<div class="section" id="allocation-dynamique-sur-la-pile">
<h3><span class="section-number">13.5.4  </span>Allocation dynamique sur la pile<a class="headerlink" href="#allocation-dynamique-sur-la-pile" title="Lien permanent vers ce titre">¶</a></h3>
<p>L'allocation dynamique sur la pile est équivalente à l'allocation sur
le tas sauf qu'elle est plus rapide (pas de recherche par le système
d'un espace suffisant et continu) et qu'elle ne nécessite pas de
libération.</p>
<p>On utilisera la fonction <em>alloca</em> (memory allocation) pour réserver de
la mémoire. Cette fonction n'initialise pas la zone réservée.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="nf">alloca</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Il est nécessaire d'inclure le fichier <em>malloc.h</em> pour utiliser cette
fonction d'allocation mémoire sur la pile. L'espace est libéré à la
sortie de la fonction appelante. On veillera tout particulièrement à ce
que le pointeur ayant reçu l'adresse de la zone mémoire réservée ne soit
pas exploité en dehors de la fonction (puisque la zone est libérée quand
on en sort).</p>
</div>
<div class="section" id="limite-d-utilisation-de-la-pile">
<h3><span class="section-number">13.5.5  </span>Limite d'utilisation de la pile<a class="headerlink" href="#limite-d-utilisation-de-la-pile" title="Lien permanent vers ce titre">¶</a></h3>
<p>L'espace mémoire utilisé par la pile est une zone dont l'usage est
uniquement dédié au programme. Si plusieurs programmes cohabitent en
mémoire, ils auront chacun leur propre pile.</p>
<p>Cet espace mémoire dédié à la pile est de taille fixe et définie lors de
la compilation du programme.</p>
<p>La pile reçoit les éléments suivants :</p>
<ul class="simple">
<li><p>les variables locales aux fonctions,</p></li>
<li><p>les variables déclarées comme paramètres dans les fonctions,</p></li>
<li><p>les informations liées aux mécanismes d'appel et de retour des
fonctions,</p></li>
<li><p>les données retournées par les fonctions,</p></li>
<li><p>les zones allouées par la fonction <code class="docutils literal notranslate"><span class="pre">alloca</span></code>.</p></li>
</ul>
<p>Étant donné que la taille de la pile est fixe, il y a un risque qu'elle
soit trop petite pour supporter toutes les informations que votre
programme doit y placer. Si cela se produit, il y a corruption de la
mémoire puisque la pile 'déborde' et que vous dépassez la zone qui lui
est dédiée.</p>
<p>Les événements suivants peuvent générer des débordements de pile :</p>
<ul class="simple">
<li><p>trop de variables locales (par exemple un grand tableau),</p></li>
<li><p>trop d'appels de fonctions en cascade,</p></li>
<li><p>utilisation de fonctions récursives (qui s'autoappellent).</p></li>
</ul>
<p>Dans le jargon informatique, on appelle ça du <em>jardinage</em> puisque vous
allez piétiner les zones mémoires voisines sans en avoir la permission.</p>
<p>Le compilateur (en réalité l'éditeur de liens - le <em>linker</em>) vous permet
de spécifier la taille de la pile ; c'est une de ses nombreuses options.</p>
</div>
</div>
<div class="section" id="variables-automatiques">
<h2><span class="section-number">13.6  </span>Variables automatiques<a class="headerlink" href="#variables-automatiques" title="Lien permanent vers ce titre">¶</a></h2>
<p>Une variable est dite <em>automatique</em> lorsque sa déclaration est faite au sein d'une fonction. La variable d'itération <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code> dans une boucle <code class="docutils literal notranslate"><span class="pre">for</span></code> est dite automatique. C'est-à-dire que le compilateur a le choix de placer cette variable :</p>
<ul class="simple">
<li><p>sur la pile ;</p></li>
<li><p>dans un registre mémoire processeur.</p></li>
</ul>
<p>Jadis, le mot clé <code class="docutils literal notranslate"><span class="pre">register</span></code> était utiliser pour forcer le compilateur à placer une variable locale dans un registre processeur pour obtenir de meilleures performances. Aujourd'hui, les compilateurs sont assez malins pour déterminer automatiquement les variables souvent utilisées.</p>
</div>
<div class="section" id="fragmentation-memoire">
<h2><span class="section-number">13.7  </span>Fragmentation mémoire<a class="headerlink" href="#fragmentation-memoire" title="Lien permanent vers ce titre">¶</a></h2>
<p>On peut observer à la figure <a class="reference internal" href="#fig-allocation"><span class="std std-numref">Fig. 13.1</span></a> qu'après un appel successif de <code class="docutils literal notranslate"><span class="pre">malloc</span></code> et de <code class="docutils literal notranslate"><span class="pre">free</span></code> des espaces mémoire non utilisés peuvent apparaître entre des régions utilisées. Ces <em>trous</em> sont appelés fragmentation mémoire.</p>
<p>Dans la figure suivante, on suit l'évolution de l'utilisation du <em>heap</em> au cours de la vie d'un programme. Au début ➀, la mémoire est libre. Tant que de la mémoire est allouée sans libération (<code class="docutils literal notranslate"><span class="pre">free</span></code>), aucun problème de fragmentation ➁. Néanmoins, après un certain temps la mémoire devient fragmentée ➂ ; il reste dans cet exemple 2 emplacements de taille 2, un emplacement de taille 5 et un emplacement de taille 8. Il est donc impossible de réserver un espace de taille 9 malgré que l'espace cumulé libre est suffisant.</p>
<div class="figure align-default" id="id3">
<img alt="../_images/fragmentation.svg" src="../_images/fragmentation.svg" /><p class="caption"><span class="caption-number">Fig. 13.3 </span><span class="caption-text">Fragmentation mémoire</span><a class="headerlink" href="#id3" title="Lien permanent vers cette image">¶</a></p>
</div>
<p>Dans une petite architecture, l'allocation et la libération fréquente d'espaces mémoire de taille arbitraire sont malvenues. Une fois que la fragmentation mémoire est installée, il n'existe aucun moyen de soigner le mal si ce n'est au travers de l'ultime solution de l'informatique : <a class="reference external" href="https://www.youtube.com/watch?v=nn2FB1P_Mn8">éteindre puis redémarrer</a>.</p>
<div class="section" id="mmu">
<h3><span class="section-number">13.7.1  </span>MMU<a class="headerlink" href="#mmu" title="Lien permanent vers ce titre">¶</a></h3>
<p>Les systèmes d'exploitation modernes (Windows, Linux, macOS...) utilisent tous un dispositif matériel nommé <a class="reference external" href="https://en.wikipedia.org/wiki/Memory_management_unit">MMU</a> pour <em>Memory Management Unit</em>. La MMU est en charge de créer un espace mémoire <strong>virtuel</strong> entre l'espace physique. Cela crée une indirection supplémentaire, mais permet de réorganiser la mémoire physique sans compromettre le système.</p>
<p>En pratique l'espace de mémoire virtuelle est toujours beaucoup plus grand que l'espace physique. Cela permet de s'affranchir dans une large mesure de problèmes de fragmentation, car si l'espace virtuel est suffisamment grand, il y aura statistiquement plus de chance d'y trouver un emplacement non utilisé.</p>
<p>La programmation sur de petites architectures matérielles (microcontrôleurs, DSP) ne possèdent pas de MMU et dès lors l'allocation dynamique est généralement à proscrire à moins qu'elle soit faite en connaissance de cause et en utilisant des mécanismes comme les <em>memory pool</em>.</p>
<p>Dans la figure ci-dessous. La mémoire physique est représentée à droite en termes de pages mémoires physiques (<em>Physical Pages</em> ou <strong>PP</strong>). Il s'agit de blocs mémoires contigus d'une taille fixe, par exemple 64 kB. Chaque page physique est mappée dans une table propre à chaque processus (programme exécutable). On y retrouve quelques propriétés utiles à savoir est-ce que la page mémoire est accessible en écriture, est-ce qu'elle peut contenir du code exécutable ? Une propriété peut indiquer par exemple si la page mémoire est valide. Chacune de ces entrées est considérée comme une page mémoire virtuelle (<em>virtual page</em> <strong>VP</strong>).</p>
<div class="figure align-default" id="id4">
<img alt="../_images/mmu.svg" src="../_images/mmu.svg" /><p class="caption"><span class="caption-number">Fig. 13.4 </span><span class="caption-text">Mémoire virtuelle</span><a class="headerlink" href="#id4" title="Lien permanent vers cette image">¶</a></p>
</div>
<div class="section" id="erreurs-de-segmentation-segmentation-fault">
<h4><span class="section-number">13.7.1.1  </span>Erreurs de segmentation (<em>segmentation fault</em>)<a class="headerlink" href="#erreurs-de-segmentation-segmentation-fault" title="Lien permanent vers ce titre">¶</a></h4>
<p>Lorsqu'un programme tente d'accéder à un espace mémoire qui n'est pas mappé dans la MMU, ou que cet espace mémoire ne permet pas le type d'accès souhaité : par exemple une écriture dans une page en lecture seule. Le système d'exploitation tue le processus avec une erreur <em>Segmentation Fault</em>. C'est la raison pour laquelle, il n'est pas systématique d'avoir une erreur de segmentation en cas de jardinage mémoire. Tant que les valeurs modifiées sont localisées au sein d'un bloc mémoire autorisé, il n'y aura pas d'erreur.</p>
<p>L'erreur de segmentation est donc générée par le système d'exploitation en levant le signal <strong>SIGSEGV</strong> (Violation d'accès à un segment mémoire, ou erreur de segmentation).</p>
</div>
</div>
<div class="section" id="memory-pool">
<h3><span class="section-number">13.7.2  </span>Memory Pool<a class="headerlink" href="#memory-pool" title="Lien permanent vers ce titre">¶</a></h3>
<p>Un <em>memory pool</em> est une méthode faisant appel à de l'allocation dynamique de blocs de taille fixe. Lorsqu'un programme doit très régulièrement allouer et désallouer de la mémoire, il est préférable que les blocs mémoires aient une taille fixe. De cette façon, après un <code class="docutils literal notranslate"><span class="pre">free</span></code>, la mémoire libérée est assez grande pour une allocation ultérieure.</p>
<p>Lorsqu'un programme est exécuté sous Windows, macOS ou Linux, l'allocation dynamique standard <code class="docutils literal notranslate"><span class="pre">malloc</span></code>, <code class="docutils literal notranslate"><span class="pre">calloc</span></code>, <code class="docutils literal notranslate"><span class="pre">realloc</span></code> et <code class="docutils literal notranslate"><span class="pre">free</span></code> sont performants et le risque de crash dû à une fragmentation mémoire est rare.</p>
<p>En revanche lors de l'utilisation sur de petites architectures (microcontrôleurs) qui n'ont pas de système sophistiqué pour gérer la mémoire, il est parfois nécessaire d'écrire son propre système de gestion de mémoire.</p>
</div>
</div>
</div>


          </div>
          <div class="page-nav">
            <div class="inner"><ul class="page-nav">
  <li class="prev">
    <a href="files.html"
       title="Chapitre précédent">← <span class="section-number">12  </span>Les  fichiers</a>
  </li>
  <li class="next">
    <a href="pointers.html"
       title="Chapitre suivant"><span class="section-number">14  </span>Pointeurs →</a>
  </li>
</ul><div class="footer" role="contentinfo">
      &#169; Copyright HEIG-VD(c) 2022.
    Mis à jour le 18 févr. 2022 (version v0.3.0-30-g2b759bb).
    <br>
    Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.2.1 with <a href="https://github.com/heig-vd-tin/sphinx_heigvd_theme">HEIG-VD Theme</a>.
</div>
            </div>
          </div>
      </page>
    </div>
    
    
  </body>
</html>