<!DOCTYPE html>
<html  lang="fr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-145664552-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-145664552-1');
    </script>
    
      <title>10 Fonctions</title>
    
      <link rel="stylesheet" href="../_static/pygments.css">
      <link rel="stylesheet" href="../_static/theme.css">
      
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>

      <!-- sphinx script_files -->
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="../_static/translations.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>

      
      <script src="../_static/theme-vendors.js"></script>
      <script src="../_static/theme.js" defer></script>
    
    <link rel="icon" href="../_static/favicon.ico" type="image/x-icon" />
  <link rel="index" title="Index" href="../genindex.html" />
  <link rel="search" title="Recherche" href="../search.html" />
  <link rel="next" title="11 Types composites" href="composite-datatypes.html" />
  <link rel="prev" title="9 Entrées Sorties" href="stdio.html" /> 
  </head>

  <body>
    <div id="app" class="theme-container" :class="pageClasses"><navbar @toggle-sidebar="toggleSidebar">
  <router-link to="../index.html" class="home-link">
    
      <span class="site-name">Le C pour l&#39;ingenieur</span>
    
  </router-link>

  <div class="links">
    <navlinks class="can-hide">

  
    <div class="nav-item">
      <a href="../index.html#le-c-pour-l-ingenieur"
         class="nav-link  router-link-active">
         Table des matières
      </a>
    </div>
  
    <div class="nav-item">
      <a href="../index.html#le-c-pour-l-ingenieur"
         class="nav-link ">
         Annexes
      </a>
    </div>
  
    <div class="nav-item">
      <a href="../index.html#le-c-pour-l-ingenieur"
         class="nav-link ">
         Références
      </a>
    </div>
  



    </navlinks>
  </div>
</navbar>

      
      <div class="sidebar-mask" @click="toggleSidebar(false)">
      </div>
        <sidebar @toggle-sidebar="toggleSidebar">
          
          <navlinks>
            

  
    <div class="nav-item">
      <a href="../index.html#le-c-pour-l-ingenieur"
         class="nav-link  router-link-active">
         Table des matières
      </a>
    </div>
  
    <div class="nav-item">
      <a href="../index.html#le-c-pour-l-ingenieur"
         class="nav-link ">
         Annexes
      </a>
    </div>
  
    <div class="nav-item">
      <a href="../index.html#le-c-pour-l-ingenieur"
         class="nav-link ">
         Références
      </a>
    </div>
  



            
          </navlinks><div id="searchbox" class="searchbox" role="search">
  <div class="caption"><span class="caption-text">Recherche rapide</span>
    <div class="searchformwrapper">
      <form class="search" action="../search.html" method="get">
        <input type="text" name="q" />
        <input type="submit" value="Recherche" />
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div><div class="sidebar-links" role="navigation" aria-label="main navigation">
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="../index.html#le-c-pour-l-ingenieur">Table des matières</a></span>
      </p>
      <ul class="current">
        
          <li class="toctree-l1 "><a href="introduction.html" class="reference internal ">Introduction</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="programming.html" class="reference internal ">La programmation</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="foundations.html" class="reference internal ">Généralités du langage</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="numeration.html" class="reference internal ">Numération</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="operators.html" class="reference internal ">Opérateurs</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="datatype.html" class="reference internal ">Types de données</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="control-structures.html" class="reference internal ">Structures de contrôle</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="processus.html" class="reference internal ">Programmes et Processus</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="stdio.html" class="reference internal ">Entrées Sorties</a>

            
          </li>

        
          <li class="toctree-l1 current"><a href="#" class="reference internal current">Fonctions</a>

            
              <ul>
                
                  <li class="toctree-l2"><a href="#conventions-d-appel" class="reference internal">Conventions d'appel</a></li>
                
                  <li class="toctree-l2"><a href="#prototype" class="reference internal">Prototype</a></li>
                
                  <li class="toctree-l2"><a href="#syntaxe" class="reference internal">Syntaxe</a></li>
                
                  <li class="toctree-l2"><a href="#parametres" class="reference internal">Paramètres</a></li>
                
                  <li class="toctree-l2"><a href="#recursion" class="reference internal">Récursion</a></li>
                
                  <li class="toctree-l2"><a href="#memoisation" class="reference internal">Mémoïsation</a></li>
                
              </ul>
            
          </li>

        
          <li class="toctree-l1 "><a href="composite-datatypes.html" class="reference internal ">Types composites</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="files.html" class="reference internal ">Les  fichiers</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="memory-management.html" class="reference internal ">Gestion de la mémoire</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="pointers.html" class="reference internal ">Pointeurs</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="standard-library.html" class="reference internal ">Bibliothèques</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="preprocessor.html" class="reference internal ">Préprocesseur</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="algorithms.html" class="reference internal ">Algorithmes et conception</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="translation-units.html" class="reference internal ">Compilation séparée</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="scopes.html" class="reference internal ">Portée et visibilité</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="testing.html" class="reference internal ">Qualité et Testabilité</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="data-structures.html" class="reference internal ">Structures de données</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="advanced-topics.html" class="reference internal ">Avancé</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="traps.html" class="reference internal ">Pièges</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="philosophy.html" class="reference internal ">Philosophie</a>

            
          </li>

        
      </ul>
    </div>
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="../index.html#le-c-pour-l-ingenieur">Annexes</a></span>
      </p>
      <ul class="">
        
          <li class="toctree-l1 "><a href="../appendix/vscode.html" class="reference internal ">Visual Studio Code</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="../appendix/grammar.html" class="reference internal ">Grammaire C</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="../appendix/bash.html" class="reference internal ">Ligne de commande</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="../appendix/development.html" class="reference internal ">Environnement de développement</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="../appendix/unit.html" class="reference internal ">Fiches d'unités de cours</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="../appendix/laboratories.html" class="reference internal ">Laboratoires</a>

            
          </li>

        
      </ul>
    </div>
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="../index.html#le-c-pour-l-ingenieur">Références</a></span>
      </p>
      <ul class="">
        
          <li class="toctree-l1 "><a href="../backmatter/exercises.html" class="reference internal ">Solution des exercices</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="../backmatter/bibliography.html" class="reference internal ">Bibliographie</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="../backmatter/glossary.html" class="reference internal ">Glossaire</a>

            
          </li>

        
      </ul>
    </div>
  
</div>
        </sidebar>

      <page>
          <div class="body-header" role="navigation" aria-label="navigation">
  
  <ul class="breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
    
    <li><span class="section-number">10  </span>Fonctions</li>
  </ul>
  

  <ul class="page-nav">
  <li class="prev">
    <a href="stdio.html"
       title="Chapitre précédent">← <span class="section-number">9  </span>Entrées Sorties</a>
  </li>
  <li class="next">
    <a href="composite-datatypes.html"
       title="Chapitre suivant"><span class="section-number">11  </span>Types composites →</a>
  </li>
</ul>
  
</div>
<hr>
          <div class="content" role="main">
            
  <div class="section" id="fonctions">
<h1><span class="section-number">10  </span>Fonctions<a class="headerlink" href="#fonctions" title="Lien permanent vers ce titre">¶</a></h1>
<div class="figure align-default" id="id1">
<a class="reference internal image-reference" href="../_images/hamilton.jpg"><img alt="Margaret Hamilton, directrice projet AGC" src="../_images/hamilton.jpg" style="width: 372.0px; height: 472.79999999999995px;" /></a>
<p class="caption"><span class="caption-number">Fig. 10.1 </span><span class="caption-text">Margaret Hamilton la directrice du projet Apollo Guidance Computer (AGC) à côté du code du projet.</span><a class="headerlink" href="#id1" title="Lien permanent vers cette image">¶</a></p>
</div>
<p>À l'époque d'Apollo 11, les fonctions n'existaient pas, le code n'était qu'une suite monolithique d'instruction ésotérique dont les sources du <a class="reference external" href="https://github.com/chrislgarry/Apollo-11">Apollo Guidance Computer</a> ont été publiées sur GitHub. Le langage est l'assembler <a class="reference external" href="https://www.ibiblio.org/apollo/yaYUL.html">yaYUL</a> dispose de sous-routines, ou procédures qui sont des fonctions sans paramètres. Ce type de langage est procédural.</p>
<p>Néanmoins, dans ce langage assembleur étrange, le code reste <strong>monolithique</strong> et toutes les variables sont globales.</p>
<p>Un programme convenablement <strong>structuré</strong> est découpé en éléments fonctionnels qui disposent pour chacun d'entrées et de sorties. De la même manière qu'un <a class="reference external" href="https://fr.wikipedia.org/wiki/L%27%C3%8Ele_aux_fleurs">télencéphale hautement développé et son pouce préhenseur</a> aime organiser sa maison en pièces dédiées à des occupations particulières et que chaque pièce dispose de rangements assignés les uns à des assiettes, les autres à des couverts, le développeur organisera son code en blocs fonctionnels et cherchera à minimiser les <a class="reference external" href="https://fr.wikipedia.org/wiki/Effet_de_bord_(informatique)">effets de bords</a>.</p>
<p>Une fonction est donc un ensemble de code exécutable délimité du programme principal et disposant :</p>
<ul class="simple">
<li><p>D'un identifiant unique</p></li>
<li><p>D'une valeur de retour</p></li>
<li><p>De paramètres d'appel</p></li>
</ul>
<p>L'utilisation des fonctions permet :</p>
<ul class="simple">
<li><p>De décomposer un programme complexe en tâches plus simples</p></li>
<li><p>De réduire la redondance de code</p></li>
<li><p>De maximiser la réutilisation du code</p></li>
<li><p>De s'abstraire des détails d'implémentation</p></li>
<li><p>D'augmenter la lisibilité du code</p></li>
<li><p>D'accroître la traçabilité à l'exécution</p></li>
</ul>
<p>En revanche, une fonction apporte quelques désavantages qui à l'échelle des ordinateurs moderne sont parfaitement négligeables. L'appel à une fonction ou sous-routine requiert du <a class="reference external" href="https://fr.wikipedia.org/wiki/Sous-programme">housekeeping</a>, qui se compose d'un prélude et d'un aboutissant et dans lequel le <a class="reference external" href="https://fr.wikipedia.org/wiki/Commutation_de_contexte">contexte</a> doit être sauvegardé.</p>
<div class="section" id="conventions-d-appel">
<span id="calling-conventions"></span><h2><span class="section-number">10.1  </span>Conventions d'appel<a class="headerlink" href="#conventions-d-appel" title="Lien permanent vers ce titre">¶</a></h2>
<p>Dans le <a class="reference external" href="https://fr.wikipedia.org/wiki/Le_Voyage_de_Chihiro">Voyage de Chihiro</a> (千と千尋の神隠し) de Hayao Miyazaki, le vieux Kamaji (釜爺) travaille dans la chaudière des bains pour l'alimenter en charbon et préparer les décoctions d'herbes pour parfumer les bains des clients.</p>
<div class="figure align-default" id="id2">
<img alt="../_images/kamaji.jpg" src="../_images/kamaji.jpg" />
<p class="caption"><span class="caption-number">Fig. 10.2 </span><span class="caption-text">Le vieux Kamaji et ses bras extensibles.</span><a class="headerlink" href="#id2" title="Lien permanent vers cette image">¶</a></p>
</div>
<p>Je vous propose bâtir une métaphore du changement de contexte en s'inspirant de cette illustration. Les murs de la chaudière sont emplis de casiers contenant différentes herbes, ces casiers peuvent être apparentés à la mémoire de l'ordinateur, et les différentes herbes, des types de données différents. De son pupitre Kamaji dispose de plusieurs mortiers dans lequel il mélange les herbes ; ils sont à l'instar de l'<a class="reference external" href="https://en.wikipedia.org/wiki/Arithmetic_logic_unit">ALU</a> d'un ordinateur le siège d'opérations transformant, à l'aide du pilon, plusieurs entrées en une seule sortie: le mélange d'herbes servant à la décoction. Bien qu'il ait six bras et afin de s'éviter des manipulations inutiles, il garde de petites réserves d'herbes à côté de son pupitre dans de petits casiers, similaires aux registres du processeur.</p>
<p>Il profite de son temps libre, pendant que les bains sont fermés pour préparer certains mélanges d'herbes les plus populaires et il place ce stock dans un casier du mur. Préparer un mélange est très similaire à un programme informatique dans lequel une suite d'opération représente une recette donnée. Le vieux Kamaji à une très grande mémoire, et il ne dispose pas de livre de recettes, mais vous, moi, n'importe qui, aurions besoin d'instructions claires du type :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">AUTUMN_TONIC_TEA</span> <span class="p">:</span>

  <span class="n">MOVE</span>  <span class="n">R1</span> <span class="nd">@B4</span>      <span class="c1"># Déplace de la grande ortie du casier B4 au registre R1</span>
  <span class="n">MOVE</span>  <span class="n">R2</span> <span class="nd">@A8</span>      <span class="c1"># Déplace la menthe verte (Mentha spicata) du casier A8 au registre R2</span>
  <span class="n">MOVE</span>  <span class="n">R3</span> <span class="nd">@C7</span>      <span class="c1"># Déplace le gingembre du casier C7 au registre R3</span>
  <span class="o">...</span>
  <span class="n">CHOP</span>  <span class="n">R4</span> <span class="n">R3</span><span class="p">,</span> <span class="n">FINE</span> <span class="c1"># Coupe très finement le gingembre et le place dans R4</span>
  <span class="o">...</span>
  <span class="n">LEAV</span>  <span class="n">R2</span> <span class="n">R5</span>       <span class="c1"># Détache les feuilles des tiges de la menthe verte, place les feuilles en R5</span>
  <span class="o">...</span>
  <span class="n">ADD</span>   <span class="n">R8</span> <span class="n">R1</span> <span class="n">R5</span>    <span class="c1"># Pilonne le contenu de R1 et R2 et place dans R8</span>
  <span class="n">ADD</span>   <span class="n">R8</span> <span class="n">R8</span> <span class="n">R4</span>
  <span class="o">...</span>
  <span class="n">STO</span>   <span class="n">R8</span> <span class="nd">@F6</span>      <span class="c1"># Place le mélange d&#39;herbe automnale tonic dans le casier F6</span>
</pre></div>
</div>
<p>Souvent, le vieux Kamaji répète les mêmes suites d'opération et ce, peu importe les herbes qu'il manipule, une fois placées dans les petits casiers (registres), il pourrait travailler les yeux fermés.</p>
<p>On pourrait résumer ce travail par une fonction C, ici prenant un rhizome et deux herbes en entrée et générant un mélange en sortie.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">blend</span> <span class="nf">slice_and_blend</span><span class="p">(</span><span class="n">rootstock</span> <span class="n">a</span><span class="p">,</span> <span class="n">herb</span> <span class="n">b</span><span class="p">,</span> <span class="n">herb</span> <span class="n">c</span><span class="p">);</span>
</pre></div>
</div>
<p>Pour des recettes complexes, il se pourrait que la fonction <code class="docutils literal notranslate"><span class="pre">slice_and_blend</span></code> soit appelée plusieurs fois à la suite, mais avec des ingrédients différents. De même que cette fonction fait appel à une autre fonction plus simple tel que <code class="docutils literal notranslate"><span class="pre">slice</span></code> (découper) ou <code class="docutils literal notranslate"><span class="pre">blend_together</span></code> (incorporer).</p>
<p>Et le contexte dans tout cela ? Il existe selon le langage de programmation et l'architecture processeur ce que l'on appelle les <a class="reference external" href="https://en.wikipedia.org/wiki/Calling_convention">conventions d'appel</a>. C'est-à-dire les règles qui régissent les interactions entre les appels de fonctions. Dans notre exemple, on adoptera peut-être la convention que n'importe quelle fonction trouvera ses ingrédients d'entrées dans les casiers R1, R2 et R3 et que le résultat de la fonction, ici le <em>blend</em>, sera placé dans le casier R8. Ainsi peu importe les herbes en entrée, le vieux Kamaji peut travailler les yeux fermés, piochant simplement dans R1, R2 et R3.</p>
<p>On observe néanmoins dans la recette évoquée plus haut qu'il utilise d'autres casiers, R4, et R5. Il faut donc faire très attention à ce qu'une autre fonction peut-être la fonction <code class="docutils literal notranslate"><span class="pre">slice</span></code>, n'utilise pas dans sa propre recette le casier R5, car sinon, c'est la catastrophe.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">herb</span> <span class="nf">slice</span><span class="p">(</span><span class="n">herb</span> <span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
<p>Kamaji entrepose temporairement les feuilles de menthe verte dans R5 et lorsqu'il en a besoin, plus tard, après avoir découpé les fleurs de <a class="reference external" href="https://fr.wikipedia.org/wiki/Mol%C3%A8ne_(plante)">molène</a> que R5 contient des tiges d'une autre plante.</p>
<p>Dans les conventions d'appel, il faut donc également donner la responsabilité à quelqu'un de ne pas utiliser certains casiers, ou alors d'en sauvegarder ou de restaurer le contenu au début et à la fin de la recette. Dans les conventions d'appel, il y en réalité plusieurs catégories de registres :</p>
<ul class="simple">
<li><p>ceux utilisés pour les paramètres de la fonction,</p></li>
<li><p>ceux utilisés pour les valeurs de retour,</p></li>
<li><p>ceux qui peuvent être utilisés librement par une fonction (la sauvegarde est à la charge du <em>caller</em>, la fonction qui appelle une autre fonction),</p></li>
<li><p>ceux qui doivent être sauvegardés par le <em>callee</em> (la fonction qui est appelée).</p></li>
</ul>
<p>En C, ce mécanisme est parfaitement automatique, le programmeur n'a pas à ce soucier du processeur, du nom des registres, de la correspondance entre le nom des herbes et le casier ou elles sont entreposées. Néanmoins, l'électronicien développeur, proche du matériel doit parfois bien comprendre ces mécanismes et ce qu'ils coûtent (en temps et en place mémoire) à l'exécution d'un programme.</p>
<div class="section" id="overhead">
<h3><span class="section-number">10.1.1  </span>Overhead<a class="headerlink" href="#overhead" title="Lien permanent vers ce titre">¶</a></h3>
<p>L'appel de fonction coûte à l'exécution, car avant chaque fonction, le compilateur ajoute automatiquement des instructions de sauvegarde et de restauration des registres utilisés :</p>
<div class="figure align-default" id="id3">
<a class="reference internal image-reference" href="../_images/calling-convention.svg"><img alt="../_images/calling-convention.svg" src="../_images/calling-convention.svg" /></a>
<p class="caption"><span class="caption-number">Fig. 10.3 </span><span class="caption-text">Sauvegarde des registres du processeur et convention d'appel de fonction.</span><a class="headerlink" href="#id3" title="Lien permanent vers cette image">¶</a></p>
</div>
<p>Ce coût est faible, très faible, un ordinateur fonctionnant à 3 GHz et une fonction complexe utilisant tous les registres disponibles, mettons 10 registres, consommera entre l'appel de la fonction et son retour 0.000'000'003 seconde, ça va, c'est raisonnable. Sauf que, si la fonction ne comporte qu'une seule opération comme ci-dessous, l'overhead sera aussi plus faible.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="stack">
<h3><span class="section-number">10.1.2  </span>Stack<a class="headerlink" href="#stack" title="Lien permanent vers ce titre">¶</a></h3>
<p>En français la <a class="reference external" href="https://fr.wikipedia.org/wiki/Pile_d%27ex%C3%A9cution">pile d'exécution</a>, est un emplacement mémoire utilisé pour sauvegarder les registres du processeur entre les appels de fonctions, sauvegarder les adresses de retour des fonctions qui sont analogue à sauvegarder le numéro de page du livre de recettes: p 443. Recette du Bras de Vénus: commencer par réaliser une génoise de 300g (p. 225). Une fois la génoise terminée, il faut se rappeler de retourner à la page 443. Enfin le <em>stack</em> est utilisé pour mémoriser les paramètres des fonctions supplémentaires qui ne tiendraient pas dans les registres d'entrées. La convention d'appel de la plupart des architectures prévoie généralement 3 registres pour les paramètres d'entrées, ci bien qu'une fonction à 4 paramètres, pourrait bien aussi utiliser le <em>stack</em>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">double</span> <span class="nf">quaternion_norm</span><span class="p">(</span><span class="kt">double</span> <span class="n">a1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">c1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">d1</span><span class="p">);</span>
</pre></div>
</div>
<p>La pile d'exécution est, comme son nom l'indique, une pile sur laquelle sont empilés et dépilés les éléments au besoin. À chaque appel d'une fonction, la valeur des registres à sauvegarder est empilée et au retour d'une fonction les registres sont dépilés si bien que la fonction d'appel retrouve le <em>stack</em> dans le même état qu'il était avant l'appel d'une fonction enfant.</p>
</div>
</div>
<div class="section" id="prototype">
<span id="function-prototype"></span><h2><span class="section-number">10.2  </span>Prototype<a class="headerlink" href="#prototype" title="Lien permanent vers ce titre">¶</a></h2>
<p>Le <a class="reference external" href="https://en.wikipedia.org/wiki/Function_prototype">prototype</a> d'une fonction est son interface avec le monde extérieur. Il déclare la fonction, son type de retour et ses paramètres d'appel. Le prototype est souvent utilisé dans un fichier d'en-tête pour construire des bibliothèques logicielles. La fonction <code class="docutils literal notranslate"><span class="pre">printf</span></code> que nous ne cessons pas d'utiliser voit son prototype résider dans le fichier <code class="docutils literal notranslate"><span class="pre">&lt;stdio.h&gt;</span></code> et il est déclaré sous la forme :</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>​int printf(const char* format, ...);
</pre></div>
</div>
<p>Notons qu'il n'y a pas d'accolades ici.</p>
<p>Rappelons-le, C est un langage impératif et déclaratif, c'est-à-dire que les instructions sont séquentielles et que les déclarations du code sont interprétées dans l'ordre ou elles apparaissent. Si bien si je veux appeler la fonction <code class="docutils literal notranslate"><span class="pre">make_coffee</span></code>, il faut qu'elle ait été déclarée avant, c'est à dire plus haut.</p>
<p>Le code suivant fonctionne :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">make_coffee</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Please wait...</span><span class="se">\n</span><span class="s">)&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">make_coffee</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Mais celui-ci ne fonctionnera pas, car <code class="docutils literal notranslate"><span class="pre">make_coffee</span></code> n'est pas connu au moment de l'appel :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">make_coffee</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">make_coffee</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Please wait...</span><span class="se">\n</span><span class="s">)&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Si pour une raison connue seule du développeur on souhaite déclarer la fonction après <code class="docutils literal notranslate"><span class="pre">main</span></code>, on peut ajouter le prototype de la fonction avant cette dernière. C'est ce que l'on appelle la déclaration avancée ou <a class="reference external" href="https://fr.wikipedia.org/wiki/D%C3%A9claration_avanc%C3%A9e">forward declaration</a>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">make_coffee</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">make_coffee</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">make_coffee</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Please wait...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Un <strong>prototype</strong> de fonction diffère de son <strong>implémentation</strong> par fait qu'il ne dispose pas du code, mais simplement sa définition, permettant au compilateur d'établir les <a class="reference internal" href="#calling-conventions"><span class="std std-ref">conventions d'appel</span></a> de la fonction.</p>
</div>
<div class="section" id="syntaxe">
<h2><span class="section-number">10.3  </span>Syntaxe<a class="headerlink" href="#syntaxe" title="Lien permanent vers ce titre">¶</a></h2>
<p>La syntaxe d'écriture d'une fonction peut être assez compliquée et la source de vérité est issue de la grammaire du langage, qui n'est pas nécessairement accessible au profane. Or, depuis <strong>C99</strong>, une fonction prend la forme :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">storage</span><span class="o">-</span><span class="n">class</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="k">return</span><span class="o">-</span><span class="nb">type</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">function</span><span class="o">-</span><span class="n">name</span><span class="o">&gt;</span> <span class="p">(</span> <span class="o">&lt;</span><span class="n">parameter</span><span class="o">-</span><span class="nb">type</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">parameter</span><span class="o">-</span><span class="n">name</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">...</span> <span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">&lt;storage-class&gt;</span></code></p>
<blockquote>
<div><p>Classe de stockage, elle n'est pas utile à ce stade du cours, nous aborderons plus tard les mots clés <code class="docutils literal notranslate"><span class="pre">extern</span></code>, <code class="docutils literal notranslate"><span class="pre">static</span></code> et <code class="docutils literal notranslate"><span class="pre">inline</span></code>.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">&lt;return-type&gt;</span></code></p>
<blockquote>
<div><p>Le type de retour de la fonction, s'agit-il d'un <code class="docutils literal notranslate"><span class="pre">int</span></code>, d'un <code class="docutils literal notranslate"><span class="pre">float</span></code> ? Le type de retour est anonyme, il n'a pas de nom et ce n'est pas nécessaire.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">&lt;function-name&gt;</span></code></p>
<blockquote>
<div><p>Il s'agit d'un <a class="reference internal" href="foundations.html#identifiers"><span class="std std-ref">identifiant</span></a> qui représente le nom de la fonction. Généralement on préfère choisir un verbe, quelquefois associé à un nom: <code class="docutils literal notranslate"><span class="pre">compute_norm</span></code>, <code class="docutils literal notranslate"><span class="pre">make_coffee</span></code>, ... Néanmoins lorsqu'il n'y a pas d'ambigüité, on peut choisir des termes plus simples tels que <code class="docutils literal notranslate"><span class="pre">main</span></code>, <code class="docutils literal notranslate"><span class="pre">display</span></code> ou <code class="docutils literal notranslate"><span class="pre">dot_product</span></code>.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">&lt;parameter-type&gt;</span> <span class="pre">&lt;parameter-name&gt;</span></code></p>
<blockquote>
<div><p>La fonction peut prendre en paramètre zéro à plusieurs paramètres chaque paramètre est défini par son type et son nom tel que: <code class="docutils literal notranslate"><span class="pre">double</span> <span class="pre">real,</span> <span class="pre">double</span> <span class="pre">imag</span></code> pour une fonction qui prendrait en paramètre un nombre complexe.</p>
</div></blockquote>
<p>Après la fermeture de la parenthèse de la liste des paramètres, deux possibilités :</p>
<dl class="simple">
<dt>Prototype</dt><dd><p>On clos la déclaration avec un <code class="docutils literal notranslate"><span class="pre">;</span></code></p>
</dd>
<dt>Implémentation</dt><dd><p>On poursuit avec l'implémentation du code <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code></p>
</dd>
</dl>
<div class="section" id="void">
<h3><span class="section-number">10.3.1  </span>void<a class="headerlink" href="#void" title="Lien permanent vers ce titre">¶</a></h3>
<p>Le type <code class="docutils literal notranslate"><span class="pre">void</span></code> est à une signification particulière dans la syntaxe d'une fonction. Il peut être utilisé de trois manières différentes :</p>
<ul>
<li><p>Pour indiquer l'absence de valeur de retour :</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>Pour indiquer l'absence de paramètres :</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">bar</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>Pour indiquer que la valeur de retour n'est pas utilisée par le parent :</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">foo</span><span class="p">(</span><span class="mi">23</span><span class="p">,</span> <span class="mi">11</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
<p>La déclaration suivante est formellement fausse, car la fonction ne possède pas un prototype complet. En effet, le nombre de paramètres n'est pas contraint et le code suivant est valide au sens de <strong>C99</strong>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">dummy</span><span class="p">()</span> <span class="p">{}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dummy</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">dummy</span><span class="p">(</span><span class="mi">120</span><span class="p">,</span> <span class="mi">144</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Aussi, il est impératif de toujours écrire des prototypes complets et d'explicitement utiliser <code class="docutils literal notranslate"><span class="pre">void</span></code> lorsque la fonction ne prend aucun paramètre en entrée. Si vous utilisez un compilateur C++, une déclaration incomplète génèrera une erreur.</p>
</div>
</div>
<div class="section" id="parametres">
<h2><span class="section-number">10.4  </span>Paramètres<a class="headerlink" href="#parametres" title="Lien permanent vers ce titre">¶</a></h2>
<p>Comme nous l'avons vu plus haut, pour de meilleures performances à l'exécution, il est préférable de s'en tenir à un maximum de trois paramètres, c'est également plus lisible pour le développeur, mais rien n'empêche d'en avoir plus.</p>
<p>En plus de cela, les <a class="reference external" href="https://fr.wikipedia.org/wiki/Param%C3%A8tre_(programmation_informatique)">paramètres</a> peuvent être passés de deux manières :</p>
<ul class="simple">
<li><p>Par valeur</p></li>
<li><p>Par référence</p></li>
</ul>
<p>En C, fondamentalement, tous les paramètres sont passés par valeur, c'est-à-dire que la valeur d'une variable est copiée à l'appel de la fonction. Dans l'exemple suivant, la valeur affichée sera bel et bien <code class="docutils literal notranslate"><span class="pre">33</span></code> et non <code class="docutils literal notranslate"><span class="pre">42</span></code></p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">alter</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">9</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">33</span><span class="p">;</span>
    <span class="n">alter</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Dans certains cas, on souhaite utiliser plus d'une valeur de retour et l'on peut utiliser un tableau. Dans l'exemple suivant, la valeur affichée sera cette fois-ci <code class="docutils literal notranslate"><span class="pre">42</span></code> et non <code class="docutils literal notranslate"><span class="pre">33</span></code>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">alter</span><span class="p">(</span><span class="kt">int</span> <span class="n">array</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">9</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">array</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">33</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">35</span><span class="p">};</span>
    <span class="n">alter</span><span class="p">(</span><span class="n">array</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Par abus de langage et en comparaison avec d'autres langages de programmation, on appellera ceci un passage par référence, car ce n'est pas une copie du tableau qui est passée à la fonction <code class="docutils literal notranslate"><span class="pre">alter</span></code>, mais seulement une référence sur ce tableau.</p>
<p>En des termes plus corrects, mais nous verrons cela au chapitre sur les pointeurs, c'est bien un passage par valeur dans lequel la valeur d'un pointeur sur un tableau est passée à la fonction <code class="docutils literal notranslate"><span class="pre">alter</span></code>.</p>
<p>Retenez simplement que lors d'un passage par référence, on cherche à rendre la valeur passée en paramètre modifiable par le <em>caller</em>.</p>
</div>
<div class="section" id="recursion">
<h2><span class="section-number">10.5  </span>Récursion<a class="headerlink" href="#recursion" title="Lien permanent vers ce titre">¶</a></h2>
<p>La récursion, caractère d'un processus, d'un mécanisme récursif, c'est à dire qui peut être répété un nombre indéfini de fois par l'application de la même règle, est une méthode d'écriture dans laquelle une fonction s'appelle elle-même.</p>
<p>Au chapitre sur les fonctions, nous avions donné l'exemple du calcul de la somme de la suite de Fibonacci jusqu'à <code class="docutils literal notranslate"><span class="pre">n</span></code> :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">fib</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">t1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">t2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">next_term</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">t1</span><span class="p">;</span>
        <span class="n">next_term</span> <span class="o">=</span> <span class="n">t1</span> <span class="o">+</span> <span class="n">t2</span><span class="p">;</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">t2</span><span class="p">;</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="n">next_term</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Il peut sembler plus logique de raisonner de façon récursive. Quelle que soit l'itération à laquelle l'on soit, l'assertion suivante est valable :</p>
<blockquote>
<div><p>fib(n) == fib(n - 1) + fib(n - 2)</p>
</div></blockquote>
<p>Donc pourquoi ne pas réécrire cette fonction en employant ce caractère récursif ?</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">fib</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Le code est beaucoup plus simple a écrire, et même à lire. Néanmoins cet algorithme est notoirement connu pour être mauvais en terme de performance. Calculer <code class="docutils literal notranslate"><span class="pre">fib(5)</span></code> revient à la chaîne d'appel suivant.</p>
<p>Cette chaîne d'appel représente le nombre de fois que <code class="docutils literal notranslate"><span class="pre">fib</span></code> est appelé et à quel niveau elle est appelée. Par exemple <code class="docutils literal notranslate"><span class="pre">fib(4)</span></code> est appelé dans <code class="docutils literal notranslate"><span class="pre">fib(5)</span></code> :</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>fib(5)
    fib(4)
        fib(3)
            fib(2)
            fib(1)
        fib(2)
            fib(1)
            fib(0)
    fib(3)
        fib(2)
            fib(1)
            fib(0)
        fib(1)
</pre></div>
</div>
<p>Si l'on somme le nombre de fois que chacune de ces fonctions est appelée :</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>fib(5)   1x
fib(4)   1x
fib(3)   2x
fib(2)   3x
fib(1)   4x
fib(0)   2x
-----------
fib(x)  13x
</pre></div>
</div>
<p>Pour calculer la somme de Fibonacci, il faut appeler 13 fois la fonction. On le verra plus tard, mais la complexité algorithmique de cette fonction est dite <span class="math notranslate nohighlight">\(O(2^n)\)</span>. C'est-à-dire que le nombre d'appels suit une relation exponentielle. La réelle complexité est donnée par la relation :</p>
<div class="math notranslate nohighlight">
\[T(n) = O\left(\frac{1+\sqrt(5)}{2}^n\right) = O\left(1.6180^n\right)\]</div>
<p>Ce terme 1.6180 est appelé <a class="reference external" href="https://fr.wikipedia.org/wiki/Nombre_d%27or">le nombre d'or</a>.</p>
<p>Ainsi pour calculer fib(100) il faudra sept cent quatre-vingt-douze trillions soixante-dix mille huit cent trente-neuf billions huit cent quarante-huit milliards trois cent soixante-quatorze millions neuf cent douze mille deux cent quatre-vingt-douze appels à la fonction <cite>fib</cite> (792'070'839'848'374'912'292). Pour un processeur Core i7 (2020) capable de calculer environ 100 GFLOPS (milliards d'opérations par seconde), il lui faudra tout de même 251 ans.</p>
<p>En revanche, dans l'approche itérative, on constate qu'une seule boucle <code class="docutils literal notranslate"><span class="pre">for</span></code>. C'est-à-dire qu'il faudra seulement 100 itérations pour calculer la somme.</p>
<p>Généralement les algorithmes récursifs (s'appelant eux-mêmes) sont moins performants que les algorithmes itératifs (utilisant des boucles). Néanmoins il est parfois plus facile d'écrire un algorithme récursif.</p>
<p>Notons que tout algorithme récursif peut être écrit en un algorithme itératif, mais ce n'est pas toujours facile.</p>
</div>
<div class="section" id="memoisation">
<h2><span class="section-number">10.6  </span>Mémoïsation<a class="headerlink" href="#memoisation" title="Lien permanent vers ce titre">¶</a></h2>
<p>En informatique la <a class="reference external" href="https://fr.wikipedia.org/wiki/M%C3%A9mo%C3%AFsation">mémoïsation</a> est une technique d'optimisation du code souvent utilisée conjointement avec des algorithmes récursifs. Cette technique est largement utilisée en <a class="reference external" href="https://fr.wikipedia.org/wiki/Programmation_dynamique">programmation dynamique</a>.</p>
<p>Nous l'avons vu précédemment, l'algorithme récursif du calcul de la somme de la suite de Fibonacci n'est pas efficace du fait que les mêmes appels sont répétés un nombre inutile de fois. La parade est de mémoriser pour chaque appel de <code class="docutils literal notranslate"><span class="pre">fib</span></code>, la sortie correspondante à l'entrée.</p>
<p>Dans cet exemple nous utiliserons un mécanisme composé de trois fonctions :</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">memoize(Cache</span> <span class="pre">*cache,</span> <span class="pre">int</span> <span class="pre">input,</span> <span class="pre">int</span> <span class="pre">output)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">memoize_has(Cache</span> <span class="pre">*cache,</span> <span class="pre">int</span> <span class="pre">input)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">memoize_get(Cache</span> <span class="pre">*cache,</span> <span class="pre">int</span> <span class="pre">input)</span></code></p></li>
</ul>
<p>La première fonction mémorise la valeur de sortie <code class="docutils literal notranslate"><span class="pre">output</span></code> liée à la valeur d'entrée <code class="docutils literal notranslate"><span class="pre">input</span></code>. Pour des raisons de simplicité d'utilisation, la fonction retourne la valeur de sortie <code class="docutils literal notranslate"><span class="pre">output</span></code>.</p>
<p>La seconde fonction <code class="docutils literal notranslate"><span class="pre">memoize_has</span></code> vérifie si une valeur de correspondance existe pour l'entrée <code class="docutils literal notranslate"><span class="pre">input</span></code>. Elle retourne <code class="docutils literal notranslate"><span class="pre">true</span></code> en cas de correspondance et <code class="docutils literal notranslate"><span class="pre">false</span></code> sinon.</p>
<p>La troisième fonction <code class="docutils literal notranslate"><span class="pre">memoize_get</span></code> retourne la valeur de sortie correspondante à la valeur d'entrée <code class="docutils literal notranslate"><span class="pre">input</span></code>.</p>
<p>Notre fonction récursive sera ainsi modifiée comme suit :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">fib</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">memoize_has</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="k">return</span> <span class="n">memoize_get</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">memoize</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Quant aux trois fonctions utilitaires, voici une proposition d'implémentation. Notons que cette implémentation est très élémentaire et n'est valable que pour des entrées inférieures à 1000. Il sera possible ultérieurement de perfectionner ces fonctions, mais nous aurons pour cela besoin de concepts qui n'ont pas encore été abordés, tels que les structures de données complexes.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define SIZE 1000</span>

<span class="kt">bool</span> <span class="n">cache_input</span><span class="p">[</span><span class="n">SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="nb">false</span> <span class="p">};</span>
<span class="kt">int</span> <span class="n">cache_output</span><span class="p">[</span><span class="n">SIZE</span><span class="p">];</span>

<span class="kt">int</span> <span class="nf">memoize</span><span class="p">(</span><span class="kt">int</span> <span class="n">input</span><span class="p">,</span> <span class="kt">int</span> <span class="n">output</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cache_input</span><span class="p">[</span><span class="n">input</span> <span class="o">%</span> <span class="n">SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">cache_output</span><span class="p">[</span><span class="n">input</span> <span class="o">%</span> <span class="n">SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="n">output</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">output</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">memoize_has</span><span class="p">(</span><span class="kt">int</span> <span class="n">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">cache_input</span><span class="p">[</span><span class="n">input</span> <span class="o">%</span> <span class="n">SIZE</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">memoize_get</span><span class="p">(</span><span class="kt">int</span> <span class="n">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">cache_output</span><span class="p">[</span><span class="n">input</span> <span class="o">%</span> <span class="n">SIZE</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="exercise" id="exercise-0">
<strong>Exercice 10.1 Dans la moyenne</strong><p>Écrire une fonction <code class="docutils literal notranslate"><span class="pre">mean</span></code> qui reçoit 3 paramètres réels et qui retourne la moyenne.</p>
</div>
<div class="exercise" id="exercise-1">
<strong>Exercice 10.2 Le plus petit</strong><p>Écrire une fonction <code class="docutils literal notranslate"><span class="pre">min</span></code> qui reçoit 3 paramètres réels et qui retourne la plus petite valeur.</p>
</div>
<div class="exercise" id="exercise-2">
<strong>Exercice 10.3 Algorithme de retour de monnaie</strong><p>On considère le cas d'une caisse automatique de parking. Cette caisse délivre des tickets au prix unique de CHF 0.50 et dispose d'un certain nombre de pièces de 10 et 20 centimes pour le rendu de monnaie.</p>
<p>Dans le code du programme, les trois variables suivantes seront utilisées :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Available coins in the parking ticket machine</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ncoin_10</span><span class="p">,</span> <span class="n">ncoin_20</span><span class="p">;</span>

<span class="c1">// How much money the user inserted into the machine (in cents)</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">amount_payed</span><span class="p">;</span>
</pre></div>
</div>
<p>Écrivez l'algorithme de rendu de la monnaie tenant compte du nombre de pièces de 10 et 20 centimes restants dans l'appareil. Voici un exemple du fonctionnement du programme :</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> <span class="nb">echo</span> <span class="s2">&quot;10 10 20 20 20&quot;</span> <span class="p">|</span> ./ptm <span class="m">30</span> <span class="m">1</span>
<span class="go">ticket</span>
<span class="go">20</span>
<span class="go">10</span>
</pre></div>
</div>
<p>Le programme reçoit sur <code class="docutils literal notranslate"><span class="pre">stdin</span></code> les pièces introduites dans la machine. Les deux arguments passés au programme <code class="docutils literal notranslate"><span class="pre">ptm</span></code> sont 1. le nombre de pièces de 10 centimes disponibles et 2. le nombre de pièces de 20 centimes disponibles. <code class="docutils literal notranslate"><span class="pre">stdout</span></code> contient les valeurs rendues à l'utilisateur. La valeur <code class="docutils literal notranslate"><span class="pre">ticket</span></code> correspond au ticket distribué.</p>
<p>Le cas échéant, s'il n'est possible de rendre la monnaie, aucun ticket n'est distribué et l'argent donné est rendu.</p>
</div>
<div class="exercise" id="exercise-3">
<strong>Exercice 10.4 La fonction f</strong><p>Considérons le programme suivant :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">x</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">x</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Quel sont les types et les valeurs retournées par les expressions ci-dessous ?</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="p">(</span><span class="mf">1.2</span><span class="p">)</span>
<span class="n">f</span><span class="p">(</span><span class="o">-</span><span class="mf">1.2</span><span class="p">)</span>
<span class="n">f</span><span class="p">(</span><span class="mf">1.6</span><span class="p">)</span>
<span class="n">f</span><span class="p">(</span><span class="o">-</span><span class="mf">1.6</span><span class="p">)</span>
</pre></div>
</div>
<p>Quel est votre conclusion sur cette fonction ?</p>
</div>
<div class="exercise" id="exercise-4">
<strong>Exercice 10.5 Mauvaise somme</strong><p>Le programme suivant compile sans erreurs graves, mais ne fonctionne pas correctement.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;math.h&gt;</span><span class="cp"></span>

<span class="kt">long</span> <span class="nf">get_integer</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="n">ok</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">result</span><span class="p">;</span>
    <span class="k">do</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Enter a integer value: &quot;</span><span class="p">);</span>
        <span class="n">fflush</span><span class="p">(</span><span class="n">stdin</span><span class="p">);</span> <span class="c1">// Empty input buffer</span>
        <span class="n">ok</span> <span class="o">=</span> <span class="p">(</span><span class="kt">bool</span><span class="p">)</span><span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%ld&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ok</span><span class="p">)</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Incorrect value.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">ok</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">long</span> <span class="n">a</span> <span class="o">=</span> <span class="n">get_integer</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">b</span> <span class="o">=</span> <span class="n">get_integer</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Quel est le problème ? À titre d'information voici ce que le programme donne, notez que l'invité de saisie n'est jamais apparu :</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ./sum
<span class="go">8527952</span>
</pre></div>
</div>
</div>
</div>
</div>


          </div>
          <div class="page-nav">
            <div class="inner"><ul class="page-nav">
  <li class="prev">
    <a href="stdio.html"
       title="Chapitre précédent">← <span class="section-number">9  </span>Entrées Sorties</a>
  </li>
  <li class="next">
    <a href="composite-datatypes.html"
       title="Chapitre suivant"><span class="section-number">11  </span>Types composites →</a>
  </li>
</ul><div class="footer" role="contentinfo">
      &#169; Copyright HEIG-VD(c) 2020.
    Mis à jour le 10 août 2020 (version v0.3.0).
    <br>
    Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.2.0 with <a href="https://github.com/heig-vd-tin/sphinx_heigvd_theme">HEIG-VD Theme</a>.
</div>
            </div>
          </div>
      </page>
    </div>
    
    
  </body>
</html>